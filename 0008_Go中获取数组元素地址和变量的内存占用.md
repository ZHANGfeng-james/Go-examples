# 数组元素的内存地址

来看一段数组变量传参的过程：

~~~go
package main

import "fmt"

func main() {
	value := [3]int{1, 2, 3}
	printAddr(value)

	test(value)
	fmt.Println(value)
}

func test(tmp [3]int) {
	tmp[0] = 0
	fmt.Println(tmp)

	printAddr(tmp)
}

func printAddr(value [3]int) {
	for index := 0; index < len(value); index++ {
		fmt.Printf("index= %d; addr= %p.\n", index, &value[index])
	}
}
PS G:\Go\SyntaxTest> go run main.go
index= 0; addr= 0xc000012400.
index= 1; addr= 0xc000012408.
index= 2; addr= 0xc000012410.
[0 2 3]
index= 0; addr= 0xc000012460.
index= 1; addr= 0xc000012468.
index= 2; addr= 0xc000012470.
[1 2 3]
~~~

数组就像是内存中连续分配的一段内存空间，这段内存可以分成一个个小的区间，每个小区间就是数组中的一个元素。因此，`&value[index]` 就是每个元素的地址！

在函数传入数组值，实际上发生的是值拷贝，具体而言是：创建了一个新的 `[3]int` 类型变量，并将源数组元素值依次写入到新创建的数组变量中，由此完成了数组的函数传参过程。从测试结果来看：`0xc000012400` 是源数组的首地址，`0xc000012460` 则是新创建数组的首地址。

# 变量的内存占用

在 Go 中**获取变量所占内存字节数**，涉及到一个方法：

~~~go
// Sizeof takes an expression x of any type and returns the size in bytes
// of a hypothetical variable v as if v was declared via var v = x.
// The size does not include any memory possibly referenced by x.
// For instance, if x is a slice, Sizeof returns the size of the slice
// descriptor, not the size of the memory referenced by the slice.
// The return value of Sizeof is a Go constant.
func Sizeof(x ArbitraryType) uintptr
~~~

**比较特殊的是**，该方法返回值的类型是 uintptr，而实际上**该类型的含义**是：

~~~go
// uintptr is an integer type that is large enough to hold the bit pattern of
// any pointer.
type uintptr uintptr
~~~

uintptr 是一个整型类型，其内存长度足够容纳一个指针值。我一直认为 uintptr 是用来存放一个指针值的，只能用来存放变量的指针值，但实际上 uintptr 可以用来存入任何整型值，其内存占用和 uint 类型相同。

~~~go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	value := make([]byte, 2, 6)
	value[0] = 1

	fmt.Println(unsafe.Sizeof(value))

	var tmp int = 0
	fmt.Println(unsafe.Sizeof(tmp)) // 在我当前的模拟平台上，int 类型值占 8 字节
}
PS G:\Go\SyntaxTest> go run main.go
24
8
~~~

理解上述程序的输出结果，还需要理解 `Sizeof` 的**注释信息**：如果变量 x 是一个切片类型，那么 `Sizeof` 返回的是 slice 描述符的内存字节长度，而**不是其引用的数据数组的长度**。

对于 value 这个变量，切片描述符的数据结构是：

~~~go
// SliceHeader is the runtime representation of a slice.
// It cannot be used safely or portably and its representation may
// change in a later release.
// Moreover, the Data field is not sufficient to guarantee the data
// it references will not be garbage collected, so programs must keep
// a separate, correctly typed pointer to the underlying data.
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
~~~

因此 `unsafe.Sizeof(value)` 占用内存字节数：8 + 8 + 8 = 24 个字节。

和 slice 类型相同，通过 unsafe.SizeOf() 获取 string 类型变量的字节信息，都只会是 16 个字节：

~~~go
// StringHeader is the runtime representation of a string.
// It cannot be used safely or portably and its representation may
// change in a later release.
// Moreover, the Data field is not sufficient to guarantee the data
// it references will not be garbage collected, so programs must keep
// a separate, correctly typed pointer to the underlying data.
type StringHeader struct {
	Data uintptr
	Len  int
}
~~~

除此之外，我们还可以**获取任何其他类型的内存占用情况**。
