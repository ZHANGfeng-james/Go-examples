Go 语言中的函数是基本程序语言的封装，以模块化的方式组织代码，让功能模块化，从而让大规模程序设计成为可能。

比如：`golang.org/x` 下各个包源文件并没有包含在 Go 项目中，而是托管在 `github.com/golang` 项目中：

![](./pics/Snipaste_2021-01-12_10-19-31.png)

可使用脚本直接更新，或者直接 clone 对应的仓库到本地：`git clone https://github.com/golang/net.git`，并指定对应的目标目录：`$GOPATH/src/golang.org/x/net`。这个项目有很多代码贡献者，他们同时参与到了一个共同的项目中。

再比如：在 Go 项目开发中引入的第三方库文件，`$GOPATH` 下的目录存在 3 个子目录：bin、`pkg`、`src`，这些目录都有什么用途？在项目中包含对应的包，比如 `golang.org/x/net` 就会将其下载到如下目录：

![](./pics/Snipaste_2021-01-12_11-19-58.png)

比如可以在 `\pkg\mod\golang.org\x\net@v0.0.0-20201224014010-6772e930b67b\html` 的目录下看到源代码。这些第三方库以功能模块的形式提供给我们，让我们在此基础上开发更复杂的项目。

上面的所有形式——不管是包管理，还是文件拆分——都体现了功能代码的封装特性，而==封装特性最基础的是：函数==。函数可以让我们将一个语句序列打包为一个单元，然后可以从程序中其他地方多次调用。函数机制可以让我们将一个大的功能分解为小的任务，这样小的任务可以让不同程序员在不同时间、不同地方独立完成。

本章的运行示例是一个**网络爬虫**，它是 Web 搜索引擎的组件之一，负责抓取网页并分析页面包含的链接，将链接指向的页面也抓取下来，循环往复。利用网络爬虫的实现，我们可以更充分地了解到 Go 语言的**递归、匿名函数、错误处理等方面的函数特性**。

# 1 函数声明

内容导读：

* 函数的声明语法；
* 函数的返回值；
* 函数的形参赋值；

每个函数声明都包含一个名字、一个形参列表、一个**可选的**返回列表以及函数体：

~~~go
func name(parameter-list) (result-list){
    body
}
~~~

形参列表指定了一组变量的参数名和参数类型，这些**局部变量**都由调用者提供的实参传递而来。返回列表则指定了函数返回值的类型。当函数==返回一个未命名的返回值==或者没有返回值的时候，返回列表的圆括号可以省略。如果一个函数既省略返回列表也没有任何返回值，那么设计这个函数的目的是调用函数之后所带来的**附加效果**。比如下述的 `hypot` 函数：

~~~go
func hypot(x, y float64) float64 {
    return math.Sqrt(x*x + y*y)
}

fmt.Println(hypot(3, 4))
~~~

**返回值也可以像形参一样命名**。这个时候，每一个**命名的返回值（相当于是在返回值列表中，使用返回类型定义一个变量）**会声明为一个**局部变量**，并根据变量类型初始化为相应的**零值**。比如下面的 test 函数，返回值类似于形参一样进行了命名，而且其初始值就是其类型的零值：

~~~go
package main

import "fmt"

func main() {
	fmt.Println("Hello, World!")
	fmt.Println("x + y:", test(3, 4))
}

func test(x, y int) (m int) {
	var z = x + y
    // 7
	fmt.Println("test(3, 4):", z)

	var t int
    // 0 + 7 = 7
	m = t + 7
	return // 必须附带上 return 语句，返回的就是 t 变量的值
}
~~~

**当函数存在返回列表时，必须显式地以 return 语句结束**，除非函数明确不会走完整个执行流程，比如在函数中抛出宕机异常或者函数体内存在一个没有 break 退出条件的无限 for 循环。

在 `hypot` 函数中使用到一种简写，如果几个形参或者返回值的类型相同，那么类型只需要写一次：

~~~go
func f(i, j, k int, s, t string){/* ... */}
func f(i int, j int, k int, s string, t string){/* ... */}
~~~

下面使用 4 种方式声明一个带有两个形参和一个返回值的函数，所有变量都是 `int` 类型。空白标识符用来强调这个形参在函数中未使用：

~~~go
package main

import "fmt"

func main() {
    // 打印函数类型声明：func(int, int) int
	fmt.Printf("%T\n", add)
	fmt.Printf("%T\n", sub)
	fmt.Printf("%T\n", first)
	fmt.Printf("%T\n", zero)
}

func add(x int, y int) int {
	return x + y
}

func sub(x, y int) (z int) { // 函数返回值像形参一样声明
	z = x - y
	return
}

func first(x int, _ int) int { // 不使用的函数形参
	return x
}

func zero(int, int) int { // 不是很理解，形参不带名字（简写）
	return 0
}
~~~

**函数的类型**称作**函数标识符**。当两个函数拥有**相同的形参列表和返回列表**时，认为这两个函数的类型或标识符是相同的。而形参和返回值的名字不会影响到函数类型，采用**简写**同样也不会影响到函数的类型。

每一次调用函数都需要提供实参来对应函数的每一个形参，包括参数的调用顺序也必须一致。在函数调用时，Go 语言没有默认参数，也没有任何方法可以通过参数名指定形参数，**形参和返回值的命名不会对调用方有任何影响**。

**形参变量都是函数的局部变量**，初始值为由调用者提供的实参值。函数形参以及命名返回值同属于**函数最外层作用域**的局部变量，被存储在相同的词法块中。

==实参是按值传递的==，所以函数接收到的是**每个实参的副本**；修改函数的形参变量并不会影响到调用者提供的实参。然而，如果提供的实参包含==引用类型==，比如==指针、slice、map、函数或者通道==，那么当函数使用形参变量时就有可能会间接地修改实参变量。

你可能偶尔会看到有些函数的声明没有函数体，那说明这个函数不是以 Go 实现的。这样的声明定义了该函数标识符：

~~~go
package main

func Sin(x float64) float64 // 使用汇编语言实现
~~~

# 2 递归

内容导读：

* 递归的概念；
* 引入 Go 的非标准包：`golang.org/x/net/html` 的使用；
* 递归调用的示例。

函数是可以递归的，这意味着**函数可以直接或间接调用自身**。对许多问题而言，递归是一种强有力的技术，例如处理递归的数据结构。在本章中，我们使用遍历来处理 HTML 文件。

下文的示例代码使用了**非标准包** `golang.org/x/net/html`，解析 HTML。`golang.org/x/...` 目录下存储了一些由 Go 团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加密解密、开发者工具提供支持的**扩展包**。未将这些扩展包加入到标准库原因有二：**一是部分包仍在开发中，二是对大多数 Go 语言的开发者而言，扩展包提供的功能很少被使用**。

Windows 平台下使用 Zeal 工具查看 Go 语言下的 Package，以 `golang.org/x/...` 开头的包有很多内容。在 Go 应用程序开发中使用这些扩展包，必须 import 对应的包：

~~~go
import "golang.org/x/net/html"
~~~

例子中调用 `golang.org/x/net/html` 的部分 `api` 如下所示：`html.Parse` 函数**读入一组 bytes 解析**（以 `io.Reader` 的方式读入）后，返回 `html.Node` 类型的 HTML 页面**树状结构根节点**。HTML 拥有很多类型的结点如 text、comment 类型，在下面的例子中，我们只关注 `<name key='value'>` 形式的结点。

~~~go
type Node struct {
    // Node 本身的定义就使用到了递归的概念
	Parent, FirstChild, LastChild, PrevSibling, NextSibling *Node

	Type      NodeType
	DataAtom  atom.Atom
	Data      string
	Namespace string
	Attr      []Attribute
}

// A NodeType is the type of a Node.
type NodeType uint32

const (
	ErrorNode NodeType = iota
	TextNode
	DocumentNode
	ElementNode
	CommentNode
	DoctypeNode
	scopeMarkerNode
)
~~~

main 函数解析 HTML 标准输入，通过递归函数 visit 获得 links，并打印出这些 links：

~~~go
...
// b --> io.Reader
doc, err := html.Parse(bytes.NewReader(b))
if err != nil {
	fmt.Fprintf(os.Stderr, "findlinks1: %v\n", err)
	os.Exit(1)
}
for _, link := range visit(nil, doc) {
	fmt.Println(link)
}
~~~

visit 函数**遍历 HTML 的节点树**，从每一个 anchor 元素的 `href` 属性获得 link，将这些 links 存入字符串数组中，并返回这个字符串数组：

~~~go
func visit(links []string, n *html.Node) []string {
    // 找到类似：<a href="/doc/">文档</a> 这种
	if n.Type == html.ElementNode && n.Data == "a" {
		for _, a := range n.Attr {
			if a.Key == "href" {
				links = append(links, a.Val)
			}
		}
	}
	// 递归遍历 FirstChild 集合
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		links = visit(links, c)
	}
	return links
}
~~~

为了遍历结点 n 的所有后代结点，每次遇到 n 的孩子结点时，visit 递归的调用自身。这些孩子结点存放在 `FirstChild` 链表中。

我们以：

1. `https://juejin.cn/backend` 掘金后端板块
2. `https://go-zh.org/` Go 编程语言中文站点

作为目标，运行 `findlinks`。我们以 fetch 的输出作为 `findlinks` 的输入：

~~~go
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
)

func main() {
	var url = "https://go-zh.org/"
	resp, err := http.Get(url)
	if err != nil {
		fmt.Fprintf(os.Stderr, "fetch:%v\n", err)
		os.Exit(1)
	}
	b, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		fmt.Fprintf(os.Stderr, "fetch:reading %s: %v\n", url, err)
		os.Exit(1)
	}
    // 打印 Web 页面的源代码
	fmt.Printf("%s", b)
}
~~~

下面是完整的工程代码：

~~~go
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"

	"golang.org/x/net/html"
)

func main() {
	var url = "https://go-zh.org/"

	resp, err := http.Get(url)
	if err != nil {
		fmt.Fprintf(os.Stderr, "fetch:%v\n", err)
		os.Exit(1)
	}
	// []byte
	b, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		fmt.Fprintf(os.Stderr, "fetch:reading %s: %v\n", url, err)
		os.Exit(1)
	}
	// fmt.Printf("%s", b)

    // b --> io.Reader
    doc, err := html.Parse(bytes.NewReader(b))
    if err != nil {
        fmt.Fprintf(os.Stderr, "findlinks1: %v\n", err)
        os.Exit(1)
    }
    for _, link := range visit(nil, doc) {
        fmt.Println(link)
    }
}

func visit(s []string, n *html.Node) []string {
	if n.Type == html.ElementNode && n.Data == "a" {
		for _, a := range n.Attr {
			if a.Key == "href" {
				links = append(links, a.Val)
			}
		}
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		links = visit(links, c)
	}
	return links
}
~~~

其输出结果为：

~~~go
/doc/
/pkg/
/project/
/help/
/blog/
http://play.golang.org/
/
#
#
http://go-tour-zh.appspot.com/
/doc/install
//blog.golang.org/
http://code.google.com/policies.html#restrictions
/LICENSE
/doc/tos.html
http://www.google.com/intl/en/policies/privacy/
~~~

> 知识点：
>
> []byte 转化为 `io.Reader`：`bytes.NewReader(b)`

在函数 outline 中，我们通过递归的方法**遍历整个 HTML 结点树**，并**输出树的结构**。在 outline 内部，**每遇到一个 HTML 元素标签**，就将其入栈，并输出：

~~~go
package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"

	"golang.org/x/net/html"
)

func main() {
	// https://go-zh.org/
	// https://juejin.cn/backend
	var url = "https://go-zh.org/"

	resp, err := http.Get(url)
	if err != nil {
		fmt.Fprintf(os.Stderr, "fetch:%v\n", err)
		os.Exit(1)
	}
	// []byte
	b, err := ioutil.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		fmt.Fprintf(os.Stderr, "fetch:reading %s: %v\n", url, err)
		os.Exit(1)
	}
	// fmt.Printf("%s", b)

	// b --> io.Reader
	doc, err := html.Parse(bytes.NewReader(b))
	if err != nil {
		fmt.Fprintf(os.Stderr, "outline: %v\n", err)
		os.Exit(1)
	}
	outline(nil, doc)
}

func outline(stack []string, n *html.Node) {
	if n.Type == html.ElementNode {
		stack = append(stack, n.Data)
		fmt.Println(stack)
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		outline(stack, c)
	}
}
~~~

`outline` 有入栈操作，但没有相对应的出栈操作。当 `outline` 调用自身时，**被调用者接收的是 stack 的拷贝**。被调用者对 stack 的元素追加操作，修改的是 stack 的拷贝，其可能会修改 slice 底层的数组甚至是申请一块新的内存空间进行扩容。但这个过程并不会修改调用方的 stack。因此当函数返回时，调用方的 stack 与其调用自身之前完全一致。

上述示例程序中 `outline` 函数包含一个 `[]string` 类型的形参，在函数体中对该 slice 调用了 append 方法：

~~~go
package main

import "fmt"

func main() {
	var stack = outline(nil)
	fmt.Println(stack)
}

func outline(stack []string) []string {
	if stack == nil {
		fmt.Println("实参 stack 为 nil！")
	}
	stack = append(stack, "AAA")
	return stack
}
~~~

Go 内置的 append 支持像 nil 中添加元素，并不会引发 panic！

下面是 `https://go-zh.org/` 页面的简要结构：

~~~go
API server listening at: 127.0.0.1:9772
[html]
[html head]
[html head meta]
[html head title]
[html head link]
[html head link]
[html head script]
[html body]
[html body div]
[html body div]
[html body div div]
[html body div div form]
...
~~~

正如在上面实验中所见，大部分 HTML 页面只需要几层递归就能处理，但仍然有些页面需要深层次的递归。

大部分编程语言使用固定大小的函数调用栈，常见的大小从 64KB 到 2MB 不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出。除此之外，还会导致安全性问题。与此相反，**Go 语言使用可变栈，栈的大小按需增加（初始时很小）**。这使得我们使用递归时==不必考虑溢出和安全问题==。

# 3 多返回值

内容导读：

* 多返回值函数；
* 函数返回值列表的参数命名；

**在 Go 中，一个函数可以返回多个值**。我们已经在之前例子中看到，许多标准库中的函数返回 2 个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。下面的例子会展示如何编写多返回值的函数。

下面的 `findlinks` 在发起 HTTP 请求后，可能会存在失败的情况，而且解析返回结果也可能失败！因此 `findlinks` 声明了 2 个返回值：**连接列表**和**错误信息**。一般而言，HTML 的解析器可以处理 HTML 页面的错误结点，构造出 HTML 页面结构，所以解析 HTML 很少失败。这意味着如果 `findlinks` 函数失败，很可能是由于 I/O 的错误导致的。

~~~go
package main

import (
	"fmt"
	"net/http"
	"os"

	"golang.org/x/net/html"
)

func main() {
	var url = "https://go-zh.org/"

	links, err := findlinks(url)
	if err != nil {
		fmt.Fprintf(os.Stderr, "findlinks2: %v\n", err)
		return
	}

	for _, link := range links {
		fmt.Println(link)
	}
}

func findlinks(url string) ([]string, error) {
	resp, err := http.Get(url)
	if err != nil {
		fmt.Fprintf(os.Stderr, "fetch:%v\n", err)
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, fmt.Errorf("getting %s: %s", url, resp.Status)
	}
	// SIGN：此处为什么可以传递 io.ReadCloser？因为 io.ReadCloser 实现了 io.Reader 接口！
	doc, err := html.Parse(resp.Body) // 参数必须是 io.Reader 接口实现类
    resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf("parsing %s as HTML: %s", url, err)
	}

	return visit(nil, doc), nil
}

func visit(links []string, n *html.Node) []string {
	if n.Type == html.ElementNode && n.Data == "a" {
		for _, a := range n.Attr {
			if a.Key == "href" {
				links = append(links, a.Val)
			}
		}
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		links = visit(links, c)
	}
	return links
}
~~~

在 `findlinks` 中，有 4 处 return 语句，每一处 return 都返回了一组值。前三处 return，将 http 和 html 包中的错误信息传递个 `findlinks` 的调用者。第一处 return 直接返回错误信息，其他两处通过 `fmt.Errorf` 输出详细的错误信息。如果 `findlinks` 成功结束，最后的 return 语句将一组解析获得的链接返回给用户。

在 `findlinks` 中，我们必须确保 `resp.Body` 被关闭，**释放网络资源**。虽然 Go 的垃圾回收机制会回收不被使用的内存，但是 GC 回收机制==不包括操作系统层面的资源==，比如打开的文件、网络连接。因此，我们**必须显式地释放这些资源**。

调用多返回值函数时，返回给调用者的是一组值，调用者必须显式地将这些值分配给变量：

~~~go
links, err := findlinks(url)
~~~

如果某个值不被使用，可以将其分配给 blank identifier：

~~~go
links, _ := findlinks(url) // errors ignored
~~~

一个函数内部可以将另一个有多返回值的函数调用作为返回值，下面的例子展示了与 `findlinks` 有相同功能的函数，两者的区别在于下面的例子先输出参数：

~~~go
func findlinksLog(url string) ([]string, error) {
    log.Printf("findllinks %s", url)
    return findlinks(url)
}
~~~

当你调用接收多参数的函数时，可以将一个返回多参数的函数调用作为该函数的参数。虽然这很少出现在实际生产代码中，但这个特性在 debug 时很方便，我们只需要一条语句就可以输出所有的返回值。下面的代码是等价的：

~~~go
log.Println(findlinks(url))

links, err := findlinks(url)
log.Println(links, err)
~~~

准确的变量名可以传达函数返回值的含义。尤其在返回值的类型都相同时，就像下面这样：

~~~go
func Size(rect image.Rectangle) (width, height int)
func Split(path string) (dir, file string)
func HourMinSec(t time.Time) (hour, minute, second int)
~~~

虽然**良好的命名很重要**，但你也不必为每一个返回值都取一个适当的名字。比如，按照惯例，函数的最后一个 bool 类型的返回值表示函数是否运行成功，error 类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释。**如果一个函数所有的返回值都有显式的变量名，那么该函数的 return 语句可以省略操作数，这称之为 bare return**。

~~~go
// CountWordsAndImages does an HTTP GET request for the HTML
// document url and returns the number of words and images in it.
func CountWordsAndImages(url string) (words, images int, err error) {
    resp, err := http.Get(url)
    if err != nil {
        return
    }
    doc, err := html.Parse(resp.Body)
    resp.Body.Close()
    if err != nil {
        err = fmt.Errorf("parsing HTML: %s", err)
        return
    }
    words, images = countWordsAndImages(doc)
    return
}
func countWordsAndImages(n *html.Node) (words, images int) {/* ... */}
~~~

按照返回值列表的次序，返回所有的返回值，在上面的例子中，每一个 return 语句等价于：

~~~go
return words, images, err
~~~

当一个函数有多处 return 语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。举个例子，如果你没有仔细地审查代码，很难发现前 2 处 return 等价于 return 0, 0, err （Go 会将返回值 words 和 images 在函数体的开始处，根据它们的类型，将其初始化为 0），最后一处 return 等价于 return words, images, nil。基于以上原因，不宜过度使用 bare return。

# 4 错误

内容导读：

* Go 语言中错误的相关常识——来自被调用函数的信号——表示发生了某个已知的 bug；
* Go 语言中内置的 error 接口类型；
* Go 语言的错误处理机制：用来处理那些未被预料到的错误，也就是 bug，而不是程序错误；
* Go 语言中处理错误的 5 种方式；
* Go 语言中函数的**代码结构**，特别是**引入了错误处理后的代码结构**。

在 Go 中有一部分函数总是能成功地运行。比如 `strings.Contains` 和 `strconv.FormatBool` 函数，对各种可能的输入都做了良好的处理，**使得运行时几乎不会失败**，除非遇到灾难性的、不可预料的情况，比如运行时的内存溢出。**导致这种错误的原因很复杂，难以处理，从错误中恢复的可能性也很低**。

还有一部分函数只要输入的参数满足一定条件，也能保证运行成功。比如 `time.Date` 函数，该函数将年月日等参数构造成 `time.Time` 对象，除非最后一个参数（时区）是 nil。这种情况下会引发 panic 异常。**panic 是来自被调用函数的信号**，表示发生了某个已知的 bug。==一个良好的程序永远不应该发生 panic 异常==。

==对于大部分函数而言，永远无法确保能否成功运行。这是因为错误的原因超出了程序的控制==。举个例子，任何进行 I/O 操作的函数都会面临出现错误的可能，**只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写**。因此，当本该可信的操作出乎意料的失败后，我们必须弄清楚导致失败的原因。

在 Go 的错误处理中，==**错误**==是软件包 API 和应用程序用户界面的一个重要组成部分，**程序运行失败仅被认为是几个预期的结果之一**。对于那些**将运行失败看作是预期结果的函数**，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为 ok。比如：`cache.Lookup` 失败的唯一原因是 key 不存在，那么代码可以按照下面的方式组织：

~~~go
value, ok := cache.Lookup(key)
if !ok {
    // ... cache[key] does not exist ...
}
~~~

通常，导致失败的原因不止一种，尤其是对 I/O 操作而言，**用户需要了解更多的错误信息**。因此，额外的返回值不再是简单的布尔类型，而是 error 类型。

内置的 error 是==接口类型==。现在我们只**需要明白 error 类型可能是 nil 或者 non-nil**。nil 意味着函数**运行成功**，non-nil 表示**运行失败**。对于 non-nil 的 error 类型，我们可以通过调用 error 的 Error 函数或者输出函数获得字符串类型的错误信息。

~~~go
fmt.Println(err)
fmt.Println("%v", err)
~~~

通常，当函数返回 non-nil 的 error 时，**其他的返回值是未定义的**，这些未定义的返回值**应该被忽略**。然而，**有少部分函数在发生错误时，仍然会返回一些有用的返回值**。比如，当读取文件发生错误时，Read 函数会返回可以读取的字节数以及错误信息。**对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误**。因此==对函数的返回值要**有清晰的说明**，以便于其他人使用==。

在 Go 中，函数运行失败时会返回错误信息，这些错误信息被认为是**一种预期的值**而非异常（Exception），这使得 Go 有别于这些**将函数运行失败看作是异常的语言**。虽然 Go 有各种异常机制，但==这些机制被使用在处理那些未被预料到的错误，即 bug==，而不是那些在健壮程序中应该被避免的程序错误。

Go 这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。

正因此，Go 使用控制流机制（如 if 和 return）处理错误，这使得==编码人员能更多地关注错误处理==。

**当一次函数调用返回错误时，调用者应该选择合适的方式处理错误**。根据==情况的不同==，有很多处理方式，让我们来看看==常用的五种方式==。

<u>首先，也是最常用的方式是**传播错误**。</u>这意味着函数中某个子程序的失败，会变成该函数的失败。下面是 `findlinks` 函数，如果 `findlinks` 对 `http.Get` 的调用失败，`findLinks` 会直接将这个 HTTP 错误返回给调用者：

~~~go
resp, err := http.Get(url)
if err != nil {
    // 将错误信息返回给调用者，向上抛出错误
    return nil, err
}
~~~

当对 `html.Parse` 的调用失败时，`findlinks` 不会直接返回 `html.Parse` 的错误，因为缺少两条重要信息：其一是发生错误时的解析器（HTML Parser）；其二是发生错误的 `url`。因此，`findlinks` 构造了一个新的错误信息，既包含了这两项，也包括了底层的解析出错的信息。

~~~go
doc, err := html.Parse(resp.Body)
resp.Body.Close()
if err != nil {
    return nil, fmt.Errorf("parsing %s as HTML: %v", url, err)
}
~~~

fmt.Errorf 函数使用 fmt.Sprintf 格式化错误信息并返回。我们使用该函数添加额外的前缀上下文信息到原始错误信息。当错误最终由 main 函数处理时，错误信息应**提供清晰的从原因到后果的因果链**，就像美国宇航局事故调查时做的那样：

~~~go
genesis: crashed: no parachute: G-switch failed: bad relay orientation
~~~

由于错误信息经常时以链式组合在一起的，所以**错误信息中应避免大写和换行符**。最终的错误信息可能很长，我们可以通过类似 grep 的工具处理错误信息。编写错误信息时，我们要**确保错误信息对问题细节的描述是详尽的**。尤其是要注意错误信息表达的==一致性==，即==相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的==。

以 os 包为例，os 包确保文件操作（如 os.Open、Read、Write、Close）返回的每个错误的描述不仅仅包含错误的原因（如无权限，文件目录不存在）也包含文件名（**添加的错误信息做到详尽**），这样调用者在构建新的错误信息时无需再添加这些信息。

一般而言，被调用函数 f(x)  会将**调用信息**和**参数信息**作为发生错误时的上下文放在错误信息中并返回给调用者，**调用者需要添加一些错误信息中不包含的信息**，比如添加 url 到 html.Parse 返回的错误中。

 让我们来看看处理错误的<u>第二种策略</u>，如果**错误的发生是偶然的**，或**由不可预知的问题导致的**，一个明智的选择是==重新尝试失败的操作==。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。

~~~go
// WaitForServer attempts to contact the server of a URL.
// It tries for one minute using exponential back-off.
// It reports an error if all attempts fail.
func WaitForServer(url string) error {
    const timeout = 1 * time.Minute
    deadline := time.Now().Add(timeout)
    for tries := 0; time.Now().Before(deadline); tries++ {
        _, err := http.Head(url)
        if err == nil {
            return nil // success
        }
        log.Printf("server not responding (%s);retrying...", err)
        // 尝试次数越多，休眠时间越长
        time.Sleep(time.Second << unit(tries)) // exponential back-off
    }
    return fmt.Errorf("server %s failed to respond after %s", url, timeout)
}
~~~

**如果错误发生后，程序无法继续运行**，我们就可以采用<u>第三种策略</u>：**输出错误信息并结束程序**。==需要注意的是，这种策略只应在 main 中执行==。对==库函数==而言，==应仅向上传播错误==，除非该错误意味着程序内部包含不一致性，即遇到了 bug，才能在库函数中结束程序。

~~~go
// (In function main.)
if err := WaitForServer(url); err != nil {
    // 调用的是 fmt 包中的函数
    fmt.Fprintf(os.Stderr, "Site is down: %v\n", err)
    os.Exit(1)
}
~~~

调用 log.Fatalf 可以以更简洁的代码达到与上文相同的效果。**log 中的所有函数，都默认会在错误信息之前输出时间信息**。

~~~go
if err := WaitForServer(url); err != nil {
    // 调用的是 log 包中的函数
    log.Fatalf("Site is down: %v\n", err)
}
~~~

长时间运行的服务器常采用默认的时间格式，而交互式工具很少采用包含如此多信息的格式。

~~~go
2006/01/02 15:04:05 Site is down: no such domain:bad.gopl.io
~~~

我们可以设置 log 的前缀信息屏蔽时间信息，一般而言，前缀信息会被设置成命令名：

~~~go
log.SetPrefix("wait: ")
log.SetFlags(0)
~~~

<u>第四种策略</u>：有时，我们==只需要输出错误信息就足够了==，必须要中断程序的运行。我们可以通过 log 包提供函数

~~~go
if err := Ping(); err != nil {
    log.Pringf("ping failed: %v; networking disabled", err)
}
~~~

或者标准错误流输出错误信息。

~~~go
if err := Ping(); err != nil {
    fmt.Fprintf(os.Stderr, "ping failed: %v; networking disabled\n", err)
}
~~~

log 包中的所有函数会为没有换行符的字符串增加换行符。

<u>第五种，也是最后一种策略</u>：我们可以直接忽略掉错误。

~~~go
dir, err := ioutil.TempDir("", "scratch")
if err != nil {
    return fmt.Errorf("failed to create temp dir: %v", err)
}
// ... use temp dir ...
os.RemoveAll(dir)
~~~

尽管 os.RemoveAll 会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期地清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响。==我们应该在每次函数调用后，都养成考虑错误处理的习惯，当你决定忽略某个错误时，你应该清晰地写下你的意图==。

在 Go 中，==错误处理有一套独特的编码风格==。**检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前**。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在 else 语句块中，而应直接放在函数体中。Go 中大部分函数的代码结构几乎相同，==首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑==。

函数经常会返回多种错误，这对终端用户来说可能会很有趣，但对程序而言，这使得情况变得复杂。很多时候，**程序必须根据错误类型，作出不同的响应**。让我们考虑这样的一个例子：从文件中读取 n 个字节。如果 n 等于文件的长度，读取过程的任何错误都表示失败。如果 n 小于文件的长度，调用者会重复地读取固定大小的数据直到文件结束。这会导致调用者必须分别处理由文件结束引起的各种错误。基于这样的原因，io 包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF，该错误在 io 包中定义：

~~~go
package io

import "errors"
// EOF is the error returned by Read when no more input is available
var EOF = errors.New("EOF")
~~~

调用者只需要通过简单的比较，就可以检测出这个错误。下面的例子展示了如何从标准输入中读取字符，以及判断文件结束：

~~~go
in := bufio.NewReader(os.Stdin)
for {
    // 天呐！怎么还可以返回 3 个返回值
    r, _, err := in.ReadRune()
    if err == io.EOF {
        break // finished reading
    }
    if err != nil {
        return fmt.Errorf("read failed: %v", err)
    }
    // ... use r...
}
~~~

因为文件结束这种错误不需要更多的描述，所以 io.EOF 有固定的错误信息——“EOF”。对于其他错误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像 io.EOF 一样采用固定的错误信息。

# 5 函数值

内容导读：

* 函数类型；
* 函数类型作为函数的形参的具体使用，也就是函数值的使用。

在 Go 中，函数被看作==第一类值==（first-class values）（函数值是作为**引用类型**存在的，也就是说并不是基本数据类型。）：**函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回**。对==函数值==（function value）的调用类似函数调用。例子如下：

~~~go
func square(n int) int { return n * n }
func negative(n int) int { return -n }
func product(m, n int) int { return m * n }

f := square // 决定了 f 变量的类型
fmt.Println(f(3))

f = negative
fmt.Println(f(3))
fmt.Printf("%T\n", f) // "func(int) int"

f = product // compile error: can't assign func(int, int) int to func(int) int
~~~

**函数类型**的零值是 nil，调用值为 nil 的函数值会引起 panic 错误：

~~~go
var f func(int) int // 声明函数类型，并初始化为 nil 值。函数值变量 f，其类型为 func(int) int
f(3)
~~~

**函数值可以与 nil 比较**：

~~~go
var f func(int) int
if f != nil {
    f(3)
}
~~~

函数值之间是不可比较的，也不能用函数值作为 map 的 key 值。

**函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为（函数）**。标准库中包含许多这样的例子。下面代码展示了如何使用这个技巧。strings.Map 对字符串中的每个字符调用 add1 函数，并将每个 add1 函数的返回值组成一个新的字符串返回给调用者：

~~~go
func add1(r rune) rune { return r + 1 }

fmt.Println(strings.Map(add1, "HAL-9000")) // "IBM.:111"
fmt.Println(strings.Map(add1, "VMS"))
fmt.Println(strings.Map(add1, "Admix"))
~~~

findlinks 函数使用了辅助函数 visit，遍历和操作了 HTML 页面的所有结点。使用函数值，我们可以**将遍历结点的逻辑和操作结点的逻辑分离**，使得我们可以==复用==遍历的逻辑，从而对结点进行不同的操作。

~~~go
package main

import(
	"fmt"
    "net/http"
    "os"
    "golang.org/x/net/html"
)

func main() {
    for _, url := range os.Args[1;]{
        outline(url)
    }
}

func outline(url string) error {
    resp, err := http.Get(url)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    doc, err := html.Parse(resp.Body)
    if err != nil {
        return err
    }
    forEachNode(doc, startElement, endElement)
    return nil
}

func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
    if pre != nil {
        // 遍历孩子结点之前，pre 被调用
        pre(n)
    }
    for c := n.FirstChild; c != nil; c = c.NextSibling {
        forEachNode(c, pre, post)
    }
    if post != nil {
        // 遍历孩子结点之后，post 被调用
        post(n)
    }
}

var depth int

func startElement(n *html.Node){
    if n.Type == html.ElementNode {
        fmt.Printf("%*s<%s>\n", depth*2, "", n.Data)
        depth++
    }
}

func endElement(n *html.Node){
    if n.Type == html.ElementNode {
        depth--
        fmt.Printf("%*s</%s>\n", depth*2, "", n.Data)
    }
}
~~~

`func forEachNode(n *html.Node, pre, post func(n *html.Node))` 接收 2 个==函数值作为参数==，分别在结点的孩子被访问前和访问后调用。这样的设计给调用者更大的灵活性。举个例子，现在我们有 startElement 和 endElement 两个函数用于输出 HTML 元素的开始标签和结束标签 `<b>...<b>`。我们得到的将会是这样的:

~~~go
<html>
  <head>
    <meta>
    </meta>
    <title>
    </title>
    <style>
    </style>
  </head>
  <body>
    <table>
      <tbody>
        <tr>
          <td>
            <a>
              <img>
              </img>
...
~~~

# 6 匿名函数

内容导读：

* 匿名函数的定义；
* 匿名函数在使用上的特点，**函数值是一种引用类型**。

**拥有函数名的函数**只能在包级语法块中被声明，通过==函数字面量==（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，**区别在于 `func` 关键字后没有函数名**。**函数字面量是一种表达式**，它的值被称为==匿名函数==。

**函数字面量允许我们在使用函数时，再定义它**。通过这种技巧，我们可以改写之前对 `strings.Map` 的调用：

~~~go
strings.Map(func(r rune) rune {return r + 1 }, "HAL-9000")
~~~

更为重要的是，通过这种方式定义的函数可以访问==完整的词法环境==，这意味着在函数中定义的内部函数可以引用该函数的变量：

~~~go
// squares 返回一个匿名函数，该匿名函数每次调用时都会返回下一个数的平方
func squares() func() int {
	var x int
	fmt.Printf("origin: %p\n", &x) // 0xc000014128 --> 0xc000014138
	return func() int {
		fmt.Printf("%p\n", &x) // 0xc000014128 --> 0xc000014138
		// 所谓的：可以访问完整的词法环境，引用该函数的变量
		x++
		return x * x
	}
}

func main() {
	f := squares() // 执行 squares() 函数，返回得到结果 func() int 函数值
	// &f address: 0xc000006038, f address: 0xd09540
	fmt.Printf("&f address: %p, f address: %p, Type: %T\n", &f, f, f)

	fmt.Println(f()) // 执行上述 func() int 函数值，
	fmt.Println(f())
	fmt.Println(f())
	fmt.Println(f())

	fOther := squares()
	// &fOther address: 0xc000006048, fOther address: 0xd09540
	fmt.Printf("&fOther address: %p, fOther address: %p, Type: %T\n", &fOther, fOther, fOther)
	fmt.Println(fOther())
}
~~~

函数 squares 返回**另一个类型为 `func() int` 的函数**。对 squares 的一次调用会生成一个局部变量 x 并**返回一个匿名函数**。每次调用匿名函数时，该函数都会先使 x 的值加 1，再返回 x 的平方。

（当多次调用外部的 squares 函数）第二次调用 squares 时，会生成第二个 x 变量，并**返回一个新的匿名函数**。**新匿名函数操作的是第二个 x 变量**。再次调用 `fOther := squares()` 时，重新定义了 `fOther` 变量，肯定的 `f` 和 `fOther` 是不同的变量，内存地址也不同，但相同的是其类型，都是 `func() int`。另外，`f` 和 `fOther` 都是函数类型，本质上是一种指针类型，其底层指向的都是 `0xd09540`，也就是说**指向的是相同的内存地址，是相同的函数**。另外在匿名函数内部引用的外部变量，比如此处的 `x` 变量，其内存地址发生了改变，也就是说生成的不同的变量。==**这种情况相当于就是说 `squares()` 中返回的匿名函数里面直接使用的就是 `x` 这个变量，隐藏的就是使用的是该变量的内存地址**==。

squares 的例子证明，**函数值**不仅仅是一串代码，还==记录了状态==。在 squares 中定义的匿名内部函数可以访问和更新 squares 中的局部变量，这意味着**匿名函数和 squares 中，存在变量引用**。==这就是函数值属于引用类型和函数值不可比较的原因==。Go 使用**闭包（closures）技术**实现函数值，Go 程序员也把**函数值**叫做闭包。

通过这个例子，我们看到**变量的生命周期不由它的作用域决定**：==**squares 返回后，变量 x 仍然隐式地存在于 f 中**==。

接下来，我们讨论一个有点学术性的例子，考虑这样一个问题：给定一些计算机课程，每个课程都有前置课程，只有完成了前置课程才可以开始当前课程的学习；我们的目标是选择出一组课程，这组课程必须确保按顺序学习时，能全部被完成。每个课程的前置课程如下：

~~~go
// prereqs记录了每个课程的前置课程
var prereqs = map[string][]string{
    "algorithms": {"data structures"},
    "calculus": {"linear algebra"},
    "compilers": {
        "data structures",
        "formal languages",
        "computer organization",
    },
    "data structures":       {"discrete math"},
    "databases":             {"data structures"},
    "discrete math":         {"intro to programming"},
    "formal languages":      {"discrete math"},
    "networks":              {"operating systems"},
    "operating systems":     {"data structures", "computer organization"},
    "programming languages": {"data structures", "computer organization"},
}
~~~

这类问题被称作拓扑排序。从概念上说，前置条件可以构成有向图。图中的顶点表示课程，边表示课程间的依赖关系。显然，图中应该无环，这也就是说从某点出发的边，最终不会回到该点。下面的代码用**深度优先搜索**了整张图，获得了符合要求的课程序列。

~~~go
package main

import (
	"fmt"
	"sort"
)

// prereqs记录了每个课程的前置课程
var prereqs = map[string][]string{
	"algorithms": {"data structures"},
	"calculus":   {"linear algebra"},
	"compilers": {
		"data structures",
		"formal languages",
		"computer organization",
	},
	"data structures":       {"discrete math"},
	"databases":             {"data structures"},
	"discrete math":         {"intro to programming"},
	"formal languages":      {"discrete math"},
	"networks":              {"operating systems"},
	"operating systems":     {"data structures", "computer organization"},
	"programming languages": {"data structures", "computer organization"},
}

func main() {
	for i, course := range topoSort(prereqs) {
		fmt.Printf("%d:\t%s\n", i+1, course)
	}
}

func topoSort(m map[string][]string) []string {
	var order []string
	seen := make(map[string]bool)

	// 定义函数值变量，类型为：func([]string)
	var visitAll func(items []string)
    
	// 对函数值变量赋值，做初始化操作
	visitAll = func(items []string) {
		// 遍历每个课程（切片的遍历）
		for _, item := range items {
			if !seen[item] {
				seen[item] = true
				// 再去遍历其前置课程
				visitAll(m[item])
				// func(items []string) 返回前，将当前 item 添加到 order 中
				order = append(order, item)
			}
		}
	}

	// 获取 map 中所有的 key（map的遍历）
	var keys []string
	for key := range m {
		keys = append(keys, key)
	}
	// 对 []string 内容排序
	sort.Strings(keys)

	visitAll(keys)
	return order
}
~~~

当匿名函数需要被递归调用时，我们必须首先声明一个变量（在上面的例子中，我们首先声明了 `visitAll`），再将匿名函数赋值给这个变量。==如果不分成两部分==，函数字面量无法与 `visitAll` 绑定，我们也无法递归调用该匿名函数。

~~~go
visitAll := func(items []string) {
    // ...
    visitAll(m[item]) // compile error:undefined visitAll
    // ...
}
~~~

上述语法模型可以抽象成为下述内容：

~~~go
package main

import "fmt"

func squares() int {
	var x = 0

    // 同样声明为匿名函数
	var visitAll func(item []string)
	visitAll = func(items []string) {
		for _, item := range items {
			fmt.Println(item)
			x++
		}
	}

	visitAll([]string{"A", "B"})
	return x
}

func main() {
	x := squares()
	fmt.Println("x =", x) // x = 2
}
~~~

本节，将介绍 Go 词法作用域的一个陷阱。请务必仔细地阅读，弄清楚发生问题的原因。即使是经验丰富的程序员也会在这个问题上犯错误。

考虑这样一个问题：你被要求首先创建一些目录，再将目录删除。在下面的例子中我们**用函数值来完成删除操作**。下面的示例代码需要引入 `os` 包。为了使代码简单，我们忽略了所有的异常处理。

~~~go
var rmdirs []func() // 定义的是 func() 的切片类型，也就是多个 func() 类型

for _, d := range tempDirs() {
    dir := d
    
    // creates parent directories too
    os.MkdirAll(dir, 0755)
    // func() 添加到切片中
    rmdirs = append(rmdirs, func(){
        os.RemoveAll(dir)
    })
}
for _, rmdir := range rmdirs {
    // 执行 func() 函数
    rmdir()
}
~~~

你可能会感到困惑，**为什么要在循环体中用循环变量 d 赋值一个新的局部变量**，而不是像下面的代码一样直接使用循环变量 `dir`。需要注意，下面的代码是错误的：

~~~go
var rmdirs []func()
for _, dir := range tempDirs(){
    os.MkdirAll(dir, 0755)
    rmdirs = append(rmdirs, func(){
        // 匿名函数中记录的是循环变量的内存地址，而不是循环变量某一时刻的值
        os.RemoveAll(dir) // NOTE: incorrect!
    })
}
~~~

问题的原因在**循环遍历的作用域**。（下述的阐述是==基于上述错误代码==的：）在上面的程序中，for 循环语句**引入了新的词法块**，循环变量 `dir` 在这个词法块中被声明。在该循环中生成的所有的函数值都**共享相同的循环变量**。需要注意，==函数中记录的是循环变量的内存地址，而不是循环变量某一时刻的值==。以 `dir` 为例，后续的迭代会不断更新 `dir` 的值，当删除操作执行时，for 循环已完成，`dir` 中存储的值等于最后一次迭代的值。这意味着，每次对 `os.RemoveAll` 的调用删除的都是相同的目录。即：**虽然 `dir` 在不断地更新内存内容，但其始终只是一个变量，也就是相同的内存地址**。

上述问题的模型可抽象为：

~~~go
package main

import "fmt"

func main() {
	values := make(map[string]int)
	values["A"] = 1
	values["B"] = 2
	fmt.Println(values)

	var rmdirs []func()
	for _, value := range values {
		// SIGN 特别重要，必须要重新创建局部变量并赋值
		tmp := value
		fmt.Println("value:", tmp)

		rmdirs = append(rmdirs, func() {
			fmt.Println("in func:", tmp)
		})
	}

	for _, rmdir := range rmdirs {
		rmdir()
	}
}
~~~

通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。比如下面的变量 `dir`，虽然这看起来很奇怪，但却很有用：

~~~go
for _, dir := range tempDirs() {
    dir := dir // declares inner dir, initialized to outer dir
    // ...
}
~~~

上述代码类似于：

~~~go
package main

import "fmt"

func main() {
	values := make(map[string]int)
	values["A"] = 1
	values["B"] = 2
	fmt.Println(values)

	for _, value := range values {
		value := value
		fmt.Println(value)
	}
}
~~~

可问题在于：==为什么上述代码能编译通过？==其原因在于：**for 循环**创建了 2 个词法块，一个是循环体本身的显式块，以及一个隐式块，它包含了一个闭合结构，其中就有初始化语句中声明的变量。也就是说，同时**使用 `:=` 声明的两个同名 value 变量，实际是在不同的词法域中创建的**。

这个问题不仅存在基于 range 的循环，在下面的例子中，对循环变量 `i` 的使用也存在同样的问题：

~~~go
var rmdirs []func()
dirs := tempDirs()
for i := 0; i < len(dirs); i++ {
    os.MkdirAll(dirs[i], 0755)
    rmdirs = append(rmdirs, func(){
        os.RemoveAll(dirs[i]) // NOTE: incorrect!
    })
}
~~~

如果你使用 go 语句或者 defer 语句会经常遇到此类问题。这不是 go 或 defer 本身导致的，而是**因为他们都会等待循环结束后，再执行函数值**。

# 7 可变参数

内容导读：

* 可变参数的含义；
* 可变参数的具体实现过程；
* 可变参数的实践。

**参数数量可变的函数**称为==可变参数函数==。典型的例子就是 fmt.Printf 和类似函数，Printf 首先接收一个必备的参数，之后接收任意个数的后续参数。

在声明可变参数函数时，需要在参数列表的**最后一个参数类型**之前加上省略符号“...”，这表示该函数会接收任意数量的该类型参数。

~~~go
func sum(vals ...int) int {
    total := 0
    for _, val := range vals {
        total += val
    }
    return total
}
~~~

sum 函数返回任意个 int 型参数的和。在函数体中，**vals 被看作是类型为 []int 的切片**。sum 可以接收任意数量的 int 型参数：

~~~go
fmt.Println(sum())
fmt.Println(sum(3))
fmt.Println(sum(1, 2, 3, 4))
~~~

在上面的代码中，**调用者隐式地创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数**。如果原始参数已经是切片类型，我们该如何传递给 sum？只需在最后一个参数后加上省略符。下面的代码功能与上个例子中最后一条语句相同。

~~~go
values := []int{1, 2, 3, 4}
fmt.Println(sum(values...))
~~~

虽然在可变参数函数内部，`...int` 型参数的行为看起来很像切片类型，但实际上，==**可变参数函数**和**以切片作为参数的函数**是不同的==。

~~~go
func f(...int) {}
func g([]int) {}
fmt.Println("%T\n", f) // "func(...int)"
fmt.Println("%T\n", g) // "func([]int)"
~~~

可变参数函数经常被用于格式化字符串。下面的 errorf 函数构造了一个以行号开头的，经过格式化的错误信息。函数名的后缀 f 是一种通用的命名规范，代表该可变参数函数可以接收 Printf 风格的格式化字符串：

~~~go
func errorf(linenum int, format string, args ...interface{}) {
    fmt.Fprintf(os.Stderr, "Line %d: ", linenum)
    fmt.Fprintf(os.Stderr, format, args...)
    fmt.Fprintln(os.Stderr)
}
linenum, name := 12, "count"
errorf(linenum, "undefined: %s", name)
~~~

`interface{}` 表示函数的最后一个参数可以接收任意类型。

本节内容可以归纳为如下实例：

~~~go
package main

import "fmt"

func main() {
	fmt.Printf("%T\n", test) // func(...int) int
	fmt.Printf("%T\n", sum)  // func([]int) int

	// 第一种调用方式
	sum := test(1, 2, 3, 4, 5)
	fmt.Println("sum:", sum)

	array := [5]int{1, 2, 3, 4, 5}
    
	slice := array[2:]
	// 第二种调用方式：直接传递的是切片
	sum = test(slice...)
	fmt.Println("sum:", sum)

	// sum = test(array) cannot use array (variable of type [5]int) as int value in argument to test
}

func test(vals ...int) int {
	var sum = 0
	for _, value := range vals {
		sum += value
	}
	return sum
}

func sum(vals []int) int {
	var sum = 0
	for value := range vals {
		sum += value
	}
	return sum
}
~~~

如果是直接调用 `sum = test(array)` 将无法通过编译，原因：`cannot use array (variable of type [5]int) as int value in argument to test`。为什么需要将 `array` 当作 `int` 类型？因为本质上 `test(vals ...int)` 是可以接收可变参数的函数，当然可以是 1 个参数也就是 `int` 类型的。

一般情况下，我们会将“可变参数”和“切片类型”做等价的类型，但是可变参数类型是和数组类型完全不一样的。

# 8 Deferred 函数

内容导读：

* Deferred 语句的含义是什么？有什么作用？
* defer 语句和 for、return 联系在一起时，具体执行顺序是怎样的？
* defer 语句和匿名函数联系在一起时，具体执行顺序是怎样的？

在 findlinks 例子中，我们用 http.Get 的输出作为 html.Parse 的输入。只有 url 的内容的确是 HTML 格式的，html.Parse 才可以正常工作，但实际上，url 指向的内容很丰富，可能是图片、纯文本或是其他。将这些格式的内容传递给 html.Parse，会产生不良后果。

下面的例子获取 HTML 页面并输出页面的标题。title 函数会检查服务器返回的 Content-Type 字段，如果发现页面不是 HTML，将终止函数运行，返回错误：

~~~go
func title(url string) error {
    resp, err := http.Get(url)
    if err != nil {
        return err
    }
    // Check Content-Type is HTML(e.g., "text/html;charset=utf-8")
    ct := resp.Header.Get("Content-Type")
    if ct != "text/html" && !strings.HasPrefix(ct, "text/html;"){
        resp.Body.Close()
        return fmt.Errorf("%s has type %s, not text/html", url, ct)
    }
    doc, err := html.Parse(resp.Body)
    resp.Body.Close()
    if err != nil {
        return fmt.Errorf("parsing %s as HTML: %v", url, err)
    }
    visitNode := func(n *html.Node) {
        if n.Type == html.ElementNode && n.Data == "title" && n.FirstChild != nil {
            fmt.Println(n.FirstChild.Data)
        }
    }
    forEachNode(doc, visitNode, nil)
    return nil
}
~~~

`resp.Body.close` 调用了多次，这是为了确保 title 在所有执行路径下（即使函数运行失败）都关闭了网络连接。**随着网络变得复杂，需要处理的错误也变多，维护清理逻辑变得越来越困难**。==而 Go 语言独有的 defer 机制可以让事情变得简单==。

你只需要在调用普通函数或方法前加上关键字 defer，就完成了 defer 所需要的语法。当执行到该条语句时，函数和参数表达式得到计算，但**直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行**，不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。==你可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反==。

Defer 语句经常被用于处理**成对的操作**，如打开、关闭；连接、断开连接；加锁、释放锁。通过 defer 机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的 defer 应该直接跟在请求资源的语句后。在下面的代码中，一条 defer 语句替代了之前的所有：

~~~go
func title(url string) error {
    resp, err := http.Get(url)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    // Check Content-Type is HTML(e.g., "text/html;charset=utf-8")
    ct := resp.Header.Get("Content-Type")
    if ct != "text/html" && !strings.HasPrefix(ct, "text/html;"){
        return fmt.Errorf("%s has type %s, not text/html", url, ct)
    }
    doc, err := html.Parse(resp.Body)
    // ...
    return nil
}
~~~

在处理其他资源时，也可以采用 defer 机制，比如对**文件的操作**：

~~~go
package ioutil

func ReadFile(filename string) ([]byte, error) {
    f, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer f.Close() // ReadAll(f) 执行结束后 才会执行 defer 后的语句
    return ReadAll(f)
}
~~~

或是处理互斥锁：

~~~go
var mu sync.Mutex
var m = make(map[string]int)
func lookup(key string) int {
    mu.Lock()
    defer mu.Unlock()
    return m[key]
}
~~~

比如下述示例代码：

~~~go
package main

import "fmt"

func main() {
	array := [5]int{1, 2, 3, 4, 5}
	slice := array[2:]

	sum := 0
	defer test(&sum, slice...)
	fmt.Println("sum:", sum) // （最先打印）sum: 0
}

func test(sum *int, vals ...int) {
	for _, value := range vals {
		*sum += value
	}
	fmt.Println("In function sum:", *sum) // （最后打印）In function sum: 12
}
~~~

另外如果 `Deferred` 语句中存在待计算的函数参数时，会首先计算函数的参数：

~~~go
package main

import "fmt"

func main() {

	array := [5]int{1, 2, 3, 4, 5}
	slice := array[2:]

	sum := 0
	tmp := 0
	defer test(&sum, runInDefer(tmp), slice...)
    fmt.Println("sum:", sum) // （打印2）sum: 0
}

func test(sum *int, tmp int, vals ...int) {
	for _, value := range vals {
		*sum += value
	}
	fmt.Println("In function sum:", *sum) // （打印3）In function sum: 12
}

func runInDefer(value int) int {
	value++
    fmt.Println("value:", value) // （打印1）value: 1
	return value
}
~~~

可以一个函数中执行**多条 defer 语句**，它们的**执行顺序与声明顺序相反**：

~~~go
package main

import "fmt"

func main() {
	sum := 0
	tmp := 1

	defer test(sum) // （打印3）value: 0
	defer test(tmp) // （打印2）value: 1

	fmt.Println("sum:", sum) // （打印1）sum: 0
}

func test(value int) {
	fmt.Println("value:", value)
}
~~~

调试复杂程序时，defer 机制也常被用于记录何时进入和退出函数。下例中的 bigSlowOperation 函数，直接调用 trace 记录函数的被调情况。bigSlowOperation 被调时，trace 会返回一个==函数值==，**该函数值会在 bigSlowOperation 退出时被调用**。通过这种方式，我们可以只通过一条语句控制函数的入口和所有的出口，甚至可以记录函数的运行时间，如例子中的 start。需要注意一点：不要忘记 defer 语句后的圆括号，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远不会被执行。

~~~go
func bigSlowOperation() {
    defer trace("bigSlowOperation")() // trace("bigSlowOperation") 会返回函数值
    // ...lots of work...
    time.Sleep(5 * time.Second)
}

func trace(msg string) func() {
    start := time.Now()
    log.Printf("enter %s", msg)
    return func() {
        log.Printf("exit %s (%s)", msg, time.Since(start))
    }
}

func main() {
    bigSlowOperation()
}
~~~

其输出的结果就是：

~~~go
API server listening at: 127.0.0.1:30861
2021/01/16 16:32:27 enter bigSlowOperation
2021/01/16 16:32:32 exit bigSlowOperation (5.005538323s)
~~~

每一次 bigSlowOperation 被调用，程序都会记录函数的进入、退出、持续时间（我们用 time.Sleep 模拟一个耗时的操作）。

在 return 语句包含有函数调用时，与之相关的 defer 语句执行顺序：

~~~go
package main

import "fmt"

func main() {
	sum := 0
	tmp := 1

	defer test(tmp) 

	fmt.Println("sum:", sum) // （打印1）sum: 0
}

func test(value int) int {
	fmt.Println("value:", value) // （打印2）value: 1

	defer fmt.Println("defer 语句执行") // （打印4）defer 语句执行

	return returnFunc() 
}

func returnFunc() int {
	fmt.Println("returnFunc()") // （打印3）returnFunc()
	return 0
}
~~~

上述示例代码执行的结果表明：对于包含有 defer 语句的函数来说，return 语句先于 defer 语句执行！

我们知道，**defer 语句中的函数会在 return 语句更新返回值变量后再执行**，又因为在函数中定义的匿名函数可以访问该函数包含返回值变量在内的所有变量。所以，对匿名函数采用 defer 机制，可以使其观察函数的返回值。

以 double 函数为例：

~~~go
func double(x int) int {
    return x + x
}
~~~

我们只需要首先命名 double 的返回值，再增加 defer 语句，我们就可以在 double 每次被调用时，输出参数以及返回值：

~~~go
func double(x int) (result int) {
    defer func() {
        fmt.Printf("double(%d) = %d\n", x, result)
    }()
    return x + x
}

_= double(4)
~~~

可能 double 函数过于简单，看不出这个小技巧的作用，但对于有许多 return 语句的函数而言，这个技巧很有用。

被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值：

~~~go
func triple(x int) (result int) {
    defer func() { 
        result += x
    }()
    return double(x)
}
fmt.Println(triple(4)) // "12"
~~~

在循环体中的 defer 语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭：

~~~go
for _, filename := range filenames {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close() // NOTE: risky; could run out of file descriptors
}
~~~

一种解决方法是将循环体中的 defer 语句移至另外一个函数。在每次循环时，调用这个函数：

~~~go
for _, filename := range filenames {
    if err := doFile(filename); err != nil {
        return err
    }
}

func doFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close()
}
~~~

`Deferred` 语句和 for 语句在一起使用的情况：

~~~go
package main

import "fmt"

func main() {
	slice := make([]int, 2)
	slice[0] = 1
	slice[1] = 2
	fmt.Println(slice) // [1 2]

	for _, value := range slice {
		defer double(value)
	}

	// 打印1 double(2)
	// 打印2 double(1)
}

func double(x int) (result int) {
	fmt.Printf("double(%d)\n", x)
	return x + x
}
~~~

类似于 `defer double(1)` 语句先声明，而后再声明 `defer double(2)`。实际的它们的**执行顺序与声明顺序相反**。

下面的代码是 fetch（1.5节） 的改进版，我们将 http 响应信息写入本地文件而不是从标准输出流输出。我们通过 path.Base 提出 url 路径的最后一段作为文件名：

~~~go
// Fetch downloads the URL and returns the name and length of the loal file.
func fetch(url string) (filename string, n int64, err error) {
    resp, err := http.Get(url)
    if err != nil {
        return "", 0, err
    }
    defer resp.Body.Close()
    local := path.Base(resp.Request.URL.Path)
    if local == "/" {
        local = "index.html"
    }
    f, err := os.Create(local)
    if err != nil {
        return "", 0, err
    }
    // 将 resp.Body 的内容写入到文件 f 中
    n, err = io.Copy(f, resp.Body)
    // Close file, but prefer error from Copy, if any.
    if closeErr := f.Close(); err == nil { // 如果 err != nil 则更倾向于将 err 反馈给调用者
        err = closeErr
    }
    return local, n, err
}
~~~

对 resp.Body.Close 延迟调用我们已经见过了，在此不做解释。上例中，通过 os.Create 打开文件进行写入，在关闭文件时，我们没有对 f.Close 采用 defer 机制，因为这会产生一些微妙的错误，**许多文件系统，尤其是 NFS，写入文件时发生的错误会被延迟到文件关闭时反馈**。如果没有检查文件关闭时的反馈信息，可能会导致数据丢失，而我们还误以为写入操作成功。也就是说 f.Close() 可能会失败！如果 io.Copy 和 f.Close() 都失败了，我们倾向于将 io.Copy 的错误信息反馈给调用者，因为它先于 f.Close() 发生，更有可能接近问题的本质。

# 9 Panic 异常

内容导读：

* Go 语言中的 panic 异常是什么
* panic 和 defer 联系在一起时，怎么执行？

Go 的类型系统会在==编译时==捕获很多错误，但==有些错误只能在运行时检查==，如**数组访问越界、空指针引用等**。**这些运行时错误会引起 panic 异常**。

> 编译时的错误，在 IDE 中直接可以捕获并修改。但是运行时错误，只有在程序真正上线运行时才会获取到。

**一般而言，当 panic 异常发生时，程序会中断运行，并立即执行在该 goroutine 中被延迟的函数**。随后，程序崩溃并输出日志信息。**日志信息包括 panic value 和函数调用的堆栈跟踪信息**。panic value 通常是某种错误信息。对于每个 goroutine，日志信息中都会有与之相对的，发生 panic 时的函数调用堆栈跟踪信息。通常，我们不需要再次运行程序去定位问题，**日志信息已经提供了足够的诊断依据**。因此，在我们填写问题报告时，一般会将 panic 异常和日志信息一并记录。

不是所有的 panic 异常都来自运行时，直接调用内置的 panic 函数也会引发 panic 异常；panic 函数接收任何值作为参数。==当某些不应该发生的场景发生时，我们就应该调用 panic==。比如，当程序到达了某条逻辑上不可能到达的路径：

~~~go
switch s := suit(drawCard()); s {
    case "Spades":
    case "Hearts":
    case "Diamonds":
    case "Clubs":
    default:
    panic(fmt.Sprintf("invalid suit %q", s))
}
~~~

==断言函数==必须满足的前置条件是明智的做法，但这很容易被滥用。除非你能提供更多的错误信息，或者能更快速地发现错误，否则不需要使用断言，编译器在运行时会帮你检查代码：

~~~go
func Reset(x *Buffer) {
    if x == nil {
        panic("x is nil") // unnecessary!
    }
    x.elements = nil
}
~~~

虽然 Go 的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同。**由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致**。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该==使用 Go 提供的错误机制==，而不是 panic，尽量避免程序的崩溃。**==在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的 I/O 操作都应该被优雅地处理，最好的处理方式，就是使用 Go 的错误机制==**。

一般而言，当 panic 异常发生时，程序会中断运行（崩溃），并立即执行在该 goroutine 中被延迟的函数（defer 机制）：

~~~go
package main

import "fmt"

func main() {
	f(3)
}

func f(x int) {
	fmt.Printf("f(%d)\n", x+0/x) // panics if x == 0
	defer fmt.Printf("defer %d\n", x)
	f(x - 1)
}
~~~

当 `f(0)` 被调用时，发生了 panic，之前被 `defer` 执行的函数将会被调用。上述代码执行输出：

~~~go
f(3)
f(2)
f(1)
defer 1
defer 2
defer 3
~~~

上述程序引发了 panic，程序将会崩溃，于此同时将立即执行被 `defer` 的语句。对于 `func f(x int)` 函数体而言，只有当函数体中的 `f(x-1)` 语句返回时才会执行 `deferred` 的语句。

显式调用 panic 时，会直接导致程序崩溃。

# 10 Recover 捕获异常

内容导读：

* Go 语言中，如何从 panic 中恢复现场——使用 recover 捕获 panic
* 什么情况下应该恢复现场？

通常来说，不应该对 panic 异常做任何处理，但有时，**也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作**。举个例子，当 web 服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使客户端一直处于等待状态。如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。

如果在 deferred 函数中调用了内置函数 recover，并且**定义该 defer 语句的函数发生了 panic 异常**，recover 会使程序从 panic 中恢复，并返回 panic value。导致 panic 异常的函数不会继续运行，但能正常返回。在未发生 panic 时调用 recover，recover 会返回 nil。看看下面的示例代码：

~~~go
package main

import "fmt"

func main() {
	err := f(0)
	fmt.Println(err)
}

func f(x int) (err error) {
	defer func() {
		if p := recover(); p != nil {
			err = fmt.Errorf("internal error: %v", p)
		}
	}()

	fmt.Printf("f(%d)\n", x+0/x) // panics if x == 0
	return err // 即便 return 语句在 defer 之前执行，但是 defer 执行后会修改 err 的值
}
~~~

让我们以语言解析器为例，说明 recover 的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将 panic 异常当作普通的解析错误，并附加额外信息提醒用户报告此错误：

~~~go
func Parse(input string) (s *Syntax, err error){
    defer func() {
        if p := recover(); p != nil {
            err = fmt.Errorf("internal error: %v", p)
        }
    }()
    // ...parser...
}
~~~

deferred 函数帮助 Parse 从 panic 中恢复。在 deferred 函数内部，panic value 被附加到错误信息中；并用 err 变量接收错误信息，返回给调用者。我们也可以通过调用 runtime.Stack 往错误信息中添加完整的堆栈调用信息。

**不加区分地恢复所有的 panic 异常，不是可取的做法**。因为在 panic 之后，无法保证包级变量的状态仍然和我们预期一致。比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放。此外，如果写日志时产生的 panic 被不加区分的恢复，可能会导致漏洞被忽略。

虽然把对 panic 的处理都集中在一个包下，有助于简化对复杂和不可预料问题的处理，**但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的 panic**。公有的 API 应该将函数的运行失败作为 error 返回，而不是 panic。同样的，你也不应该恢复一个由他人开发的函数引起的 panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。

有时我们很难完全遵循规范，举个例子，net/http 包中提供了一个 web 服务器，将受到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的 panic 异常，杀掉整个进程。web 服务器遇到处理函数导致的 panic 时会调用 recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为 recover 操作，导致其他问题。

基于以上原因，==安全的做法是有选择性的 recover==。换句话说，==**只恢复应该被恢复的 panic 异常**==。此外，这些异常所占的比例应该尽可能的低。为了标识某个 panic 是否应该被恢复，我们可以将 panic value 设置成特殊类型。在 recover 时对 panic value 进行检查，如果发现 panic value 是特殊类型，就将这个 panic 作为 error 处理，如果不是，则按照正常的 panic 进行处理。

下面的例子是 title 函数的变形，如果 HTML 页面包含多个 <title>，该函数会给调用者返回一个错误。在 soleTitle 内部处理时，如果检测到有多个 <title>，会调用 panic，阻止函数继续递归，并将特殊类型 bailout 作为 panic 的参数：

~~~go
fuc soleTitle(doc *html.Node) (title string, err error) {
    type bailout struct{}
    defer func() {
        switch p := recover(); p {
            case nil:
            case bailout{}:
            err = fmt.Errorf("multiple title elements)
                             default:
                             panic(p)
        }
    }()
        forEachNode(doc, func(n *html.Node){
            if n.Type == html.ElementNode & n.Data == "title" && n.FirstChild != nil {
                if title != "" {
                    panic(bailout{})
                }
                title = n.FirstChild.Data
            }
        }, nil)
        if title == "" {
            return "", fmt.Errorf("no title element")
        }
        return title, nil
}
~~~

在上例中，deferred 函数调用 recover，并检查 panic value。当 panic value 是 bailout{} 类型时，deferred 函数生成一个 error 返回给调用者。当 panic value 是其他 non-nil 值时，表示发生了未知的 panic 异常，deferred 函数将调用 panic 函数并将当前的 panic value 作为参数传入；此时，等同于 recover 没有做任何操作。

有些情况下，我们无法恢复。某些致命错误会导致 Go 在运行时终止程序，如内存不足。