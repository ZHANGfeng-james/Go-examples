参考：[几点忠告 · Go语言圣经 (studygolang.com)](https://books.studygolang.com/gopl-zh/ch12/ch12-09.html)

Go 语言提供了一种机制，能够**在运行时**更新变量和检查他们的值、调用他们的方法和他们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为**反射**。反射也可以让我们**将类型本身作为第一类的值类型**处理。

在本章，我们将探讨 Go 语言的反射特性，看看它可以给语言增加哪些表达力，以及在两个至关重要的 API 是如何使用**反射机制**的：一个是 `fmt` 包提供的字符串格式化功能，另一个是类似 `encoding/json` 和 `encoding/xml` 提供的针对特定协议的编解码功能。对于我们在之前章节看到的 `text/tmplate` 和 `html/template` 包，它们的实现也是**依赖反射技术**的。然后，**反射是一个复杂的内省技术，不应该随意使用**，因此，尽管**上面这些包内部都是用反射技术实现的**，但是它们自己的 API 都没有公开反射相关的接口。

> encoding/json 和 encoding/xml 其内部都使用了**反射机制**实现的。

## 为何需要反射？

有时候我们需要编写一个函数能够处理一类并不满足普通公共接口的类型的值，也可能是因为它们并没有确定的表示方式，或者是在我们设计该函数的时候**这些类型可能还不存在**。这种情况中，一般使用的是 `interface{}` 类型作为入参类型。

一个大家熟悉的例子是 `fmt.Fprintf` 函数提供字符串格式化处理逻辑，它可以用来对**任意类型的值**格式化并打印，甚至**支持用户自定义的类型（很明显，这种就是支持了还不存在类型的格式化打印功能）**。让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和 `fmt.Sprint` 类似的格式化后的字符串。我们实现的函数名也叫 `Sprint`。

我们首先用 `swtich` 类型分支来测试输入参数是否实现了 String 方法，如果是的话就调用该方法。然后继续增加类型测试分支，检查这个**值**的**动态类型**是否是 `string/int/bool` 等基础类型，并在每种情况下执行响应的格式化操作：

~~~go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	fmt.Println(Sprint("A"))
}

func Sprint(x interface{}) string {
	type stringer interface {
		String() string
	}
    // switch 语句特有的，能获取 x 变量的类型信息
	switch x := x.(type) {
	case stringer:
		return x.String()
	case string:
		return x
	case int:
		return strconv.Itoa(x)
	// ... similar cases for int16, uint32, and so on
	case bool:
		if x {
			return "true"
		}
		return "false"
	default:
		// array, chan, func, map, pointer, slice, struct
		return "???"
	}
}
~~~

但是我们如何处理其他类似 `[]float64`、`map[string][]string` 等类型呢？我们当然可以添加更多的测试分支，但是**这些组合类型的数据基本是无穷的**。还有如何处理类似 `url.Values` 这样的命名类型呢？即使类型分支可以识别出底层的基础类型是 `map[string][]string`，但是它并不匹配 `url.Values` 类型，**因为他们是两种不同的类型**，而且 switch 类型分支也不可能包含每个底层类型是 `url.Values` 的命名类型，这**会导致对这些（外部）库的依赖**。

没有办法来**检查未知类型**的表示方式，**我们被卡住了**。**这就是我们为何需要反射的原因**。

> 对于一个 `interface{}` 类型的变量，可以被赋予任何类型的值。此时，这个变量具有 2 个动态属性：**动态类型**和**动态值**。
>
> 其中，动态类型对应的就是下述的 reflect.Type 类型变量值；动态值，对应的就是下述的 reflect.Value 类型变量值。

## `reflect.Type` 和 `reflect.Value`

反射是由 reflect 包提供的。它定义了两个重要的类型：Type 和 Value。

一个 Type 表示一个 Go 类型，它是一个**接口**，有许多方法来区分类型以及检查它们的组成部分，例如一个结构体的成员或一个函数的参数等。唯一能反映 `reflect.Type` 实现的是接口的**类型描述信息**，**也正是这个实体标识了接口值的动态类型**：

~~~go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	t := reflect.TypeOf("A")
	fmt.Println(t.String()) // string
	fmt.Println(t) // string
	fmt.Printf("%T\n", t) // *reflect.rtype
}
~~~

其中 `TypeOf("A")` 调用将值字符串 A 传给 `interface{}` 参数。**将一个具体的值转为接口类型会有一个隐式的接口转换操作**，它会创建一个包含**两个信息**的接口值：**操作数**的**动态类型**（这里是 string） 和它的**动态值**（这里是 A）。

因为 `reflect.TypeOf` 返回的是一个动态类型的接口值，它**总是返回具体的类型**。因此，下面的代码将打印 `*os.File` 而不是 `io.Writer`：

~~~go
var w io.Writer = os.Stdout
fmt.Println(reflect.TypeOf(w)) // *os.File
~~~

要注意的是 `reflect.Type` 接口是满足 `fmt.Stringer` 接口的。因为打印一个接口的动态类型对于调试和日志是有帮助的，`fmt.Printf` 提供了一个缩写 `%T` 参数，内部使用 `reflect.TypeOf` 来输出：

~~~go
fmt.Printf("%T\n", 3) // int

// 特别注意
fmt.Printf("%T\n", reflect.TypeOf(t)) // *reflect.rtype
fmt.Println(reflect.TypeOf(t)) // string
~~~

在获取值的动态类型时，使用的 API 调用链是：

~~~go
// TypeOf returns the reflection Type that represents the dynamic type of i.
// If i is a nil interface value, TypeOf returns nil.
func TypeOf(i interface{}) Type {
	eface := *(*emptyInterface)(unsafe.Pointer(&i))
	return toType(eface.typ)
}

// toType converts from a *rtype to a Type that can be returned
// to the client of package reflect. In gc, the only concern is that
// a nil *rtype must be replaced by a nil Type, but in gccgo this
// function takes care of ensuring that multiple *rtype for the same
// type are coalesced into a single Type.
func toType(t *rtype) Type {
	if t == nil {
		return nil
	}
	return t
}
~~~

可以看到，TypeOf 函数返回的值类型是 `*(reflect.rtype)`——rtype 是 reflect 包中的类型，而返回的是**该类型的指针类型**。上述类型可直接写成 `*reflect.rtype` 类型。此外，`*reflect.rtype` 类型是实现了 reflect.Type 接口的，也就是 `*reflect.rtype` 是 Type 接口的一个实例。

reflect 包中另一个重要的类型是 `Value`：一个 `reflect.Value` 可以**装载任意类型的值**。函数 `reflect.ValueOf` 接受任意的 `interface{}` 类型，并返回一个装载着其动态值的 `reflect.Value`。和 `reflect.TypeOf` 类似，`reflect.ValueOf` 返回的结果也是具体的类型，但是 `reflect.Value` 也可以持有一个接口值：

~~~go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var a interface{} = "A"
	v := reflect.ValueOf(a)
	fmt.Println(v)          // A
	fmt.Printf("%T\n", v)   // reflect.Value
	fmt.Printf("%v\n", v)   // A
	fmt.Println(v.String()) // A
}
~~~

和 `reflect.Type` 类似，`reflect.Value` 也满足 `fmt.Stringer` 接口，但是除非 Value 持有的是字符串，否则 String 方法只返回其类型，而使用 `fmt` 包的 %v 标志参数会对 `reflect.Values` 特殊处理。

我们来看看调用 reflect.ValueOf 函数的调用链：

~~~go
// ValueOf returns a new Value initialized to the concrete value
// stored in the interface i. ValueOf(nil) returns the zero Value.
func ValueOf(i interface{}) Value {
	if i == nil {
		return Value{}
	}

	// TODO: Maybe allow contents of a Value to live on the stack.
	// For now we make the contents always escape to the heap. It
	// makes life easier in a few places (see chanrecv/mapassign
	// comment below).
	escapes(i)

	return unpackEface(i)
}

// unpackEface converts the empty interface i to a Value.
func unpackEface(i interface{}) Value {
	e := (*emptyInterface)(unsafe.Pointer(&i))
	// NOTE: don't read e.word until we know whether it is really a pointer or not.
	t := e.typ
	if t == nil {
		return Value{}
	}
	f := flag(t.Kind())
	if ifaceIndir(t) {
		f |= flagIndir
	}
	return Value{t, e.word, f}
}

// Value is the reflection interface to a Go value.
//
// Not all methods apply to all kinds of values. Restrictions,
// if any, are noted in the documentation for each method.
// Use the Kind method to find out the kind of value before
// calling kind-specific methods. Calling a method
// inappropriate to the kind of type causes a run time panic.
//
// The zero Value represents no value.
// Its IsValid method returns false, its Kind method returns Invalid,
// its String method returns "<invalid Value>", and all other methods panic.
// Most functions and methods never return an invalid value.
// If one does, its documentation states the conditions explicitly.
//
// A Value can be used concurrently by multiple goroutines provided that
// the underlying Go value can be used concurrently for the equivalent
// direct operations.
//
// To compare two Values, compare the results of the Interface method.
// Using == on two Values does not compare the underlying values
// they represent.
type Value struct {
	// typ holds the type of the value represented by a Value.
	typ *rtype

	// Pointer-valued data or, if flagIndir is set, pointer to data.
	// Valid when either flagIndir is set or typ.pointers() is true.
	ptr unsafe.Pointer

	// flag holds metadata about the value.
	// The lowest bits are flag bits:
	//	- flagStickyRO: obtained via unexported not embedded field, so read-only
	//	- flagEmbedRO: obtained via unexported embedded field, so read-only
	//	- flagIndir: val holds a pointer to the data
	//	- flagAddr: v.CanAddr is true (implies flagIndir)
	//	- flagMethod: v is a method value.
	// The next five bits give the Kind of the value.
	// This repeats typ.Kind() except for method values.
	// The remaining 23+ bits give a method number for method values.
	// If flag.kind() != Func, code can assume that flagMethod is unset.
	// If ifaceIndir(typ), code can assume that flagIndir is set.
	flag

	// A method value represents a curried method invocation
	// like r.Read for some receiver r. The typ+val+flag bits describe
	// the receiver r, but the flag's Kind bits say Func (methods are
	// functions), and the top bits of the flag give the method number
	// in r's type's method table.
}
~~~

reflect.ValueOf 函数返回了一个 Value 结构体类型的实例。这个结构体类型，在这个类型上，实现了很多与之相关的方法，比如 Elem、Field 等。

对 Value 值调用其 Type 方法将返回具体类型所对应的 `reflect.Type`：

~~~go
t := v.Type() // *reflect.rtype
fmt.Println(t.String())
~~~

`reflect.ValueOf` 的**逆操作**是 `reflect.Value.Interface` 方法，它返回一个 `interface{}` 类型，装载着与 `reflect.Value` 相同的具体值：

~~~go
v := reflect.ValueOf(3)
x := v.Interface()
i := x.(int)
fmt.Printf("%d\n", i)
~~~

`reflect.Value` 和 `interface{}` 都能装载任意的值，所不同的是，一个空的接口隐藏了值内部的表示方式和所有方法，因此只有我们知道具体的动态类型才能使用**类型断言**来访问内部的值（就像上面那样），内部值我们没法访问，相比之下，**一个 `Value` 则有很多方法来检查其内容，无论它的具体类型是什么**。让我们再次尝试实现我们的格式化函数 `format.Any`。

> v, ok := x.(int) 就是一个**类型断言**，也就是推断 x 接口变量的动态类型

我们使用 `reflect.Value` 的 **Kind 方法**来替代之前的类型 switch。虽然还是有无穷多的类型，但是它们的 kinds 类型却是有限的：

1. Bool，String 和所有数字类型的基础类型；
2. Array 和 Struct 对应的聚合类型；
3. Chan、`Func`、`Ptr`、Slice 和 Map 对应的引用类型；
4. interface 类型。
5. 表示空值的 Invalid 类型（空的 `reflect.Value` 的 kind 即为 Invalid）。

在 reflect 包中，具体定义了如下的 Kind：

~~~go
// A Kind represents the specific kind of type that a Type represents.
// The zero Kind is not a valid kind.
type Kind uint

const (
	Invalid Kind = iota
	Bool
	Int
	Int8
	Int16
	Int32
	Int64
	Uint
	Uint8
	Uint16
	Uint32
	Uint64
	Uintptr
	Float32
	Float64
	Complex64
	Complex128
	Array
	Chan
	Func
	Interface
	Map
	Ptr
	Slice
	String
	Struct
	UnsafePointer
)
~~~

如上，包含了 Go 语言中所有的基本类型。

~~~go
package main

import (
	"fmt"
	"reflect"
	"strconv"
	"time"
)

func main() {
	var x int64 = 1
	var d time.Duration = 1 * time.Nanosecond // time.Duration 类型是 int64 的别名类型
	fmt.Println(Any(x))                       // "1"
	fmt.Println(Any(d))                       // "1"
	fmt.Println(Any([]int64{x}))              // "[]int64 0x8202b87b0"
	fmt.Println(Any([]time.Duration{d}))      // "[]time.Duration 0x8202b87e0"
}

// Any formats any value as a string.
func Any(value interface{}) string {
	return formatAtom(reflect.ValueOf(value))
}

// formatAtom formats a value without inspecting its internal structure.
func formatAtom(v reflect.Value) string {
	switch v.Kind() {
	case reflect.Invalid:
		return "invalid"
	case reflect.Int, reflect.Int8, reflect.Int16,
		reflect.Int32, reflect.Int64:
		return strconv.FormatInt(v.Int(), 10)
	case reflect.Uint, reflect.Uint8, reflect.Uint16,
		reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return strconv.FormatUint(v.Uint(), 10)
	// ...floating-point and complex cases omitted for brevity...
	case reflect.Bool:
		return strconv.FormatBool(v.Bool())
	case reflect.String:
		return strconv.Quote(v.String())
	case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:
		return v.Type().String() + " 0x" +
			strconv.FormatUint(uint64(v.Pointer()), 16)
	default: // reflect.Array, reflect.Struct, reflect.Interface
		return v.Type().String() + " value"
	}
}
~~~

到目前为止，我们的函数将每个值视作一个不可分割没有内部结构的物品，因此它叫 `formatAtom`。对于聚合类型（结构体和数组）和接口，只是打印值的类型，对于引用类型（channel、function、pointer、slice 和 map）打印类型和十六进制的引用地址。虽然还不够理想，但是依然是一个重大的进步，并且 Kind 只关心底层表示，`format.Any` 也支持别名类型。

**reflect.Type 和 reflect.Value，分别都是 reflect 包下的类型。它们分别表示的是接口值中的动态类型和动态值，而动态值也可获取到其类型信息。**

## Display，一个递归的值打印器

接下来，让我们看看如何改善聚合数据类型的显示。我们并不想完全克隆一个 `fmt.Sprint` 函数，我们只是构建一个用于调试用的 `Display` 函数：给定任意一个复杂类型 x，打印这个值对应的完整结构，同时标记每个元素的发现路径。让我们从这个例子开始：

~~~

~~~



## 通过 `reflect.Value` 修改值

到目前为止，反射还只是程序中变量的另一种读取方式。然而，在本节中我们将重点讨论如何通过反射机制来修改变量。



# 获取结构体字段标签

在前面的内容中，我们使用结构体成员标签设置 JSON 对应的名字。其中 JSON 成员标签让我们可以选择成员的名字或者是零值成员的输出。在本节，我们将看到如何通过**反射机制类**获取**结构体字段的标签**。

对于一个 Web 服务，大部分 HTTP 处理函数要做的第一件事情：**解析请求中的参数，并存储到内存中的变量**。我们定义了一个**工具函数**，叫 params.Unpack，通过使用**结构体成员标签机制**来让 HTTP 处理函数解析请求参数更方便。

首先，我们看看如何使用它：下面的 search 函数是**一个 HTTP 请求处理函数**。它定义了一个匿名结构体类型的变量，用结构体的每个成员表示 HTTP 请求的参数。其中**结构体成员标签**指明了对于请求参数的名字，为了减少 URL 的长度这些参数名通常都是神秘的缩略词。Unpack **将请求参数填充到合适的结构体成员中**，这样我们可以方便地通过合适的类型类来访问这些参数。

~~~go
package main

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"
)

type Data struct {
	Labels     []string `http:"labels"`
	MaxResults int      `http:"max"`
	Exact      bool     `http:"exact"`
}

func main() {
	data := Data{
		MaxResults: 10,
	}

	// 模拟 req.ParseForm()，解析出 URL 中的 key-value
	type Values map[string][]string
	form := make(Values)
	form["labels"] = []string{"a", "b", "c"}
	form["exact"] = []string{"true"}
	// URL 中的 key-value 对应解析到 Data 结构体变量中
	Unpack(form, &data)

	fmt.Println(data)
}
~~~

下面的 Unpack 函数主要**完成 3 件事情**：

1. 它调用 req.ParseForm() 来解析 HTTP 请求。req.Form 将包含所有的请求参数，不管 HTTP 客户端使用的是 GET 还是 POST 请求方法；我们直接使用一个 map 值模拟 *http.Request 中 key-value 的解析过程；
2. 构建每个结构体成员有效参数名字到成员变量的映射。如果结构体成员有成员标签的话，有效参数名字可能和实际的成员名字不相同。reflect.Type 的 Field 方法将返回一个 reflect.StructField，里面含有**每个成员的名字、类型和可选的成员标签**等信息。其中成员标签信息对应 reflect.StructTag 类型的字符串，并且提供了 Get 方法用于解析和根据特定 key 提取的子串，例如这里的 `http:"..."` 形式的子串；
3. Unpack 遍历 HTTP请求的 name/value 参数键值对，更新相应的结构体成员。回想一下，同一个名字的参数可能出现多次。如果发生这种情况，并且对应的结构体成员是一个slice，那么就将所有的参数添加到slice中。其它情况，对应的成员值将被覆盖，只有最后一次出现的参数值才是起作用的。

~~~go
func Unpack(form map[string][]string, ptr interface{}) error {
	valueOf := reflect.ValueOf(ptr) // the pointer variable
	ele := valueOf.Elem()           // the struct variable
	fmt.Println(valueOf, fmt.Sprintf("%T", valueOf))
	fmt.Println(ele, fmt.Sprintf("%T", ele))

	// 获取 Data 结构体的 Field 信息
	fields := make(map[string]reflect.Value)
	for i := 0; i < ele.NumField(); i++ {
		// 获取 ele 的类型值 reflect.Type
		fieldInfo := ele.Type().Field(i)
		tag := fieldInfo.Tag
		name := tag.Get("http")
		if name == "" {
			name = strings.ToLower(fieldInfo.Name)
		}
		fields[name] = ele.Field(i) // labels --> <[]string Value>
	}
	// map[exact:<bool Value> labels:<[]string Value> max:<int Value>]
	fmt.Println(fields)

	for name, values := range form {
		// 取到 name 对应的 reflect.Value
		f := fields[name]
		if !f.IsValid() {
			continue
		}

		for _, value := range values {
			if f.Kind() == reflect.Slice {
				// reflect.Slice 的元素类型，依据该类型创建一个ptr
				elem := reflect.New(f.Type().Elem()).Elem()
				if err := populate(elem, value); err != nil {
					return fmt.Errorf("%s: %v", name, err)
				}
				f.Set(reflect.Append(f, elem))
			} else {
				if err := populate(f, value); err != nil {
					return fmt.Errorf("%s: %v", name, err)
				}
			}
		}
	}

	return nil
}

func populate(v reflect.Value, value string) error {
	switch v.Kind() {
	case reflect.String:
		// reflect.Value 其底层值设置为 value
		v.SetString(value)
	case reflect.Int:
		i, err := strconv.ParseInt(value, 10, 64)
		if err != nil {
			return err
		}
		v.SetInt(i)
	case reflect.Bool:
		b, err := strconv.ParseBool(value)
		if err != nil {
			return err
		}
		v.SetBool(b)
	default:
		return fmt.Errorf("unsupported kind %s", v.Type())
	}
	return nil
}

~~~

populate函数小心用请求的字符串类型参数值来填充单一的成员v（或者是slice类型成员中的单一的元素）。目前，它仅支持字符串、有符号整数和布尔型。

