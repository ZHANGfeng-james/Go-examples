Go 语言的内置基本类型、平台默认支持的函数在 `./builtin/builtin.go` 中定义。

在理解**基本类型**和**引用类型**是，有一个很重要的特征：==**Go 语言中，在给函数或方法传递参数时，均是传值的**==。

1. 如果是基本数据类型，则会发生一次拷贝，将值的副本传递给函数或方法；
2. 如果是引用类型，实际在传递值的时候是传递了一个指针，这个指针就是应用类型变量的内存地址。

==基本类型的指针赋值==问题：

~~~go
package main

import (
	"fmt"
	"log"

	"test.go/cmd"
)

func main() {
	var intPtr *int
	i := 1                  // 定义的常量 1 实际是 int 类型，而不是 int8、int32 等类型
	intPtr = &i
	fmt.Println(*intPtr)                // 1，含义：输出指向的内存地址的值
    fmt.Printf("%p, %p\n", &i, intPtr)  // &i 和 intPtr 都是 *int 类型，需要按照 %p 格式输出，输出内容相同说明指向关系正确
	var ptr *int
	*ptr = 1   // 引发 panic
}
~~~

详细的 panic 信息如下：

~~~go
panic: runtime error: invalid memory address or nil pointer dereference
[signal 0xc0000005 code=0x1 addr=0x0 pc=0xea285a]

goroutine 1 [running]:
main.main()
        C:/Users/Developer/test.go/main.go:17 +0x13a
exit status 2
~~~

`fmt.Printf("%p, %p\n", &i, intPtr)` 对于 `intPtr` 而言，输出的是其指向的内存地址，也就是变量 `i` 的内存地址。

出现 panic 的原因：value 变量是 `*int` 类型，但其并没有指向任何变量（内存地址，也就是说**没有分配对应的内存空间用来存储值**），`fmt.Printf("%p, %v\n", ptr, ptr)` 输出 `0x0` 值，和 panic 信息对应！`%v` 输出结果为 `nil`。

==使用类型 Type 定义变量==：比如基本数据类型 `int`、bool 等

~~~go
package main

import (
	"fmt"
)

func main() {
	value := string("ss") // value 变量已经声明为了 string 类型
	value = int(1) // cannot use int(1) (constant 1 of type int) as string value in assignment 也就是类型不匹配！
	fmt.Println(value)
}
~~~

用这种方式定义了变量 value，其类型是 `int`，其值是 1。

==基本类型和 new 关键字组合使用==：

~~~go
package main

import "fmt"

func main() {
	var value = new(int)
	*value = 1
	fmt.Println(*value)
}
~~~

使用 `new(int)` 获取到的是 `*int` 类型的变量。

==string 字符串的遍历，以及和 rune 的关系==：

~~~go
package main

import (
	"fmt"
	"unicode"
)

func main() {
	var s = "aétéa"
	var letters []rune

	for i, r := range s {
		fmt.Printf("%d --> %d\n", i, r) // 97 233 116 233 97
		var isLetter = unicode.IsLetter(r)
		fmt.Println(isLetter)
		if isLetter {
			letters = append(letters, unicode.ToLower(r))
		}
	}

	for i := range s {
		fmt.Println(i) // 0 1 3 4 6
		if s[i] != s[len(s)-1-i] {

		}
	}
}

/**
	0 --> 97
	1 --> 233
	3 --> 116
	4 --> 233
	6 --> 97
	0
	1
	3
	4
	6
**/

~~~

我们从 `range` 输出的结果来看：

1. 如果 `:= range` 左侧仅有 1 个变量：其值则是 rune 的字节索引，并不是按照字节顺序依次增加；
2. 如果 `:= range` 左侧有 2 个变量：前者和上述序列结果一致，后者则是组成 rune 的值。

==string 类型有一个特别的地方==：

~~~go
const template = `Warning: you are using %d bytes of storage,%d%% of your quota.`

package main

import (
	"fmt"
)

func main() {
	const template = `Warning`
	fmt.Printf("%T\n", template)
    
	// string --> []byte
	bytes := []byte(template)
	fmt.Println(len(bytes))
}
~~~

`template` 的类型始终都是 string。

==rune 类型到底怎么理解？==`type rune int32` 之间的关系是什么？

the UTF-8 encoding of Unicode code point

rune 和定义字符的区别？

~~~go
func main() {
	fmt.Printf("Fields are: %q", strings.Fields("1   foo bar  baz   2"))

	isSpace := unicode.IsSpace('_') // 用来表示 rune ？
	fmt.Println(isSpace)
}
~~~

什么时候 rune 变量所占字节不是 1？

`Unicode code point ` 又是什么？