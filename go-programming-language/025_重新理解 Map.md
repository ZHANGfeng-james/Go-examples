==定义 nil 值的 Map 变量==，什么情况下 Map 变量值为 nil？

定义 Map 有 3 种方式：

1. `var value map[string]int`：其值为 nil；
2. `value := make(map[string]ing)`：其值不为 nil；
3. `value := map[string](int){}`：其值不为 nil。

和 map 对应的是 slice，也是具有上述相类似的声明方法！

对值为 nil 的 Map 做取值操作，并不会报类似 Java 的空指针异常，而是会返回 Value 类型的零值。但是如果对 Map 做赋值操作，向 Map 添加 key-value 则会引发 panic。与之相关示例代码如下：

~~~go
func main() {
	maps := make(map[string]int)
	fmt.Printf("%p\n", maps)

	var mapOther map[string]int // nil
	fmt.Printf("%p\n", mapOther)

	values := mapOther["a"]     // nil map 取值
	fmt.Printf("%d\n", values)
	mapOther["a"] = 1           // 向 nil map 填充 key-value 引发 panic
	values = mapOther["a"]
	fmt.Printf("%d\n", values)

	var slice []string
	fmt.Printf("%p\n", slice)
	slice[0] = "a"              // 向 nil 的 Slice 中填充元素引发 panic
}
~~~

Map 和 Slice 类似，如果使用类似 `var mapOther map[string]int` 方式定义变量，对 Map 的取值操作不会有任何问题，即便其中没有对应的 key-value；但是不能对其添加 key-value，否则会引发 panic。

==Map 变量值为 nil 时，对其取值情况==：

~~~go
package main

import (
	"fmt"
)

type Flag struct {
	Name     string
	Usage    string
	Value    string
	DefValue string
}

type FlagSet struct {
	name   string
	format map[string]*Flag  // 定义 Map 变量
}

func main() {
	f := &FlagSet{
		name: "test",
	}

    // 结构体变量 f 并没有对 format 初始化，也就是 format 为 nil
	if f.format == nil {
		fmt.Println("map is nil!")

        // 即便 format 为 nil，但并不妨碍取值过程
		_, alreadythere := f.format["ant"]
		if alreadythere {
			fmt.Println("exists the key")
		} else {
			fmt.Println("does not exists the key")
		}
	}
    
	var value map[string]int // value := make(map[string]int)
	if value == nil {
		fmt.Println("map is nil")
	} else {
		value["a"] = 1
	}

	tmp, alreadythere := value["a"]  // 即便 format 为 nil，但并不妨碍取值过程
	if !alreadythere {
		fmt.Println("not exists")
		return
	}

	fmt.Printf("tmp:%d\n", tmp)
}
~~~

==Map 的取值==，如果 `:=` 操作符左侧有 2 个变量分别取到什么值？如果 `:=` 操作符左侧有 1 个变量又是什么含义？

~~~go
	...
    tmp, alreadythere := value["a"]  // 即便 format 为 nil，但并不妨碍取值过程
	if !alreadythere {
		fmt.Println("not exists")
		return
	}

	fmt.Printf("tmp:%d\n", tmp)
}
~~~

比如上述代码，如果 `:=` 操作符左侧**有 2 个变量时**，依次表示的是：value 和是否存在的标志 alreadythere；如果**仅有一个变量时**，则获取到的是 value，这种情况下如果 Map 中不存在该 key，则获取到的是 Value 类型的零值。

==Map 的遍历==：

~~~go
package main

import "fmt"

func main() {
	var value map[string]int

	value = map[string]int{"a": 1, "b": 2}

	for key := range value { // 遍历时，仅返回一个值，该值为 key
		fmt.Println(key)
	}

	for key, value := range value {
		fmt.Printf("key=%s, value=%d\n", key, value) // 遍历时，返回 2 个值，该值分别是 key 和 value
	}
}
~~~

使用 range 遍历时，仅返回一个值，该值为 key；使用 range 遍历时，返回 2 个值，该值分别是 key 和 value。

**==Map 中 key-value 的修改（更新）问题==**：

先来看一个简单的 Map 例子：

~~~go
func main() {
	var v map[int]string
	value := make(map[int]string)
	value1 := map[int]string{}

	fmt.Printf("%v, %T, %p\n", v, v, v) // nil
	fmt.Printf("%v, %T, %p\n", value, value, value)
	fmt.Printf("%v, %T, %p\n", value1, value1, value1)

	value[0] = "0"
	value[1] = "1"
	fmt.Printf("%v\n", value)

	value[1] = "2"            // 用这种方式修改 key-value，相当于是一次更新操作
	fmt.Printf("%v\n", value)
}
~~~

上述这种简单的 Map 是这样的类型：`key-value` 对应的是 `int-string`。使用 `value[1] = "2"` 的方式相当于再次向 Map 填充了 `key-value` 对，那此时原先已存在该 key，也就是相当于更新操作。

下面再看一个复杂的例子：`key-value` 对应的是 `string-[]string`

~~~go
func main() {
	value := make(map[string][]string)

	slice := make([]string, 0, 2)
	slice = append(slice, "1")

	value["1"] = slice
	// map[1:[1]]
	fmt.Printf("%v\n", value)

	slice = append(slice, "2")
	fmt.Printf("%v, %p, %v, %v\n", slice, slice, cap(slice), len(slice)) // [1 2], 0xc0000044e0, 2, 2

	// map[1:[1]]
	fmt.Printf("%v\n", value)
	tmp, alreadyThere := value["1"]
	if alreadyThere {
		fmt.Printf("%v, %p, %d, %d.\n", tmp, tmp, cap(tmp), len(tmp))

		newSlice := tmp[:cap(tmp)]
		fmt.Println(newSlice) // [1, 2]
	}

	value["1"] = slice // update 更新 key-value
	fmt.Printf("%v\n", value) // map[1:[1 2]]
}

map[1:[1]], 0xc0000044c0, 0xc0000044a0, 2, 1.
[1 2], 0xc0000044c0, 2, 2.
[1], 0xc0000044c0, 2, 1.
[1 2]
~~~

上面的结果很奇怪！

1. 第 9 行原本认为的输出是 `map[1:[1 2]]` 但其结果却是 `map[1:[1]]`；
2. 原本认为 slice 和 tmp 是相同内容的 Slice 实例，但是通过 `cap` 和 `len` 操作的结果来看，并不相同；但是毕竟两者的底层数组都是相同的。

看了很多关于介绍 Map 使用的博客，大多只写了：初始化、插入、删除、遍历，但就是没有提到**更新操作**。

针对上述情况，一个合理的解释是：==在将 `key-value` 填入到 Map 中时，实际上是做了值的拷贝，虽然 Slice 底层指向的仍然是相同的数组==。但是 slice 本质上是一个 struct 结构体类型，在存入 map 时，会做一次值的拷贝，也就是说会拷贝 slice 底层的 struct 的值。虽然 slice 会直接去处理底层数组，而且多个 slice 都是引用了相同的底层数组，但是 length 和 capacity 的值是有区别的。另一方面，从 `newSlice := tmp[:cap(tmp)]` 输出结果可以看出，确实能够验证自己的想法！

那如果将上述的 map 定义做更改变：`value := make(map[string]*[]string)` 就会得到正确的结果

~~~go
func main() {
	value := make(map[string]*[]string)

	slice := make([]string, 0, 2)
	slice = append(slice, "1")
	value["1"] = &slice
	fmt.Printf("%v, %p, %p, %d, %d.\n", value, slice, &slice, cap(slice), len(slice))

	slice = append(slice, "2")
	fmt.Printf("%v, %p, %d, %d.\n", slice, slice, cap(slice), len(slice))

	getValue, alreadyThere := value["1"]
	if alreadyThere {
		fmt.Printf("%v, %p, %d, %d.\n", getValue, getValue, cap(*getValue), len(*getValue))
	}
}

map[1:0xc0000044a0], 0xc0000044c0, 0xc0000044a0, 2, 1.
[1 2], 0xc0000044c0, 2, 2.
&[1 2], 0xc0000044a0, 2, 2.
~~~

通过上述实例验证：`%p` 输出 slice 的值时，得到的是底层数组的首地址（当然作为变量 slice，也是有对应的内存地址的，也就是 `0xc0000044a0`）。存放在 map 中的实际上是 `*[]string` 类型的指针，也就是变量 slice 的内存地址。从最后 `getValue` 获取到的地址来看，依然处理的是 `0xc0000044a0` 这个变量的值。

进一步来看看关于==**函数间传递 Map 参数**==的情况：

~~~go
func main() {
	value := make(map[string][]string)

	slice := make([]string, 0, 2)
	slice = append(slice, "1")
	fmt.Printf("%v, %v\n", len(slice), cap(slice))
	fmt.Printf("%v, %p\n", slice, slice)

	value["1"] = slice
	// map[1:[1]]
	fmt.Printf("%v\n", value)

	funcTest(value)
	fmt.Printf("%v\n", value) // map[1:[1] 2:[2]]
}

func funcTest(value map[string][]string) {
	v := value["1"]
	// []string, [1]
	fmt.Printf("value type: %T, %v, %p\n", v, v, v)

	v = append(v, "2")
	fmt.Printf("%v, %v\n", len(v), cap(v))
	fmt.Printf("%v, %p, %v\n", v, v, value)

	slice := make([]string, 0, 2)
	slice = append(slice, "2")
	value["2"] = slice
	fmt.Printf("%v\n", value) // map[1:[1] 2:[2]]
}
~~~

Map 类型是指针类型，在调用函数中更改了 Map 对象会对所有的引用产生影响。