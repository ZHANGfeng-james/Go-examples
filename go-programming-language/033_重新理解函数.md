





函数调用中==**栈的大小问题**==：

『大部分编程语言使用固定大小的函数调用栈，常见的大小从 64KB 到 2MB 不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出。除此之外，还会导致安全性问题。与此相反，**Go 语言使用可变栈，栈的大小按需增加（初始时很小）**。这使得我们使用递归时==不必考虑溢出和安全问题==。』

为什么 Go 使用的是可变栈？

==**匿名函数**==是如何实现引用外部局部变量的，从而导致变量的生命周期发生改变？

~~~go
// squares 返回一个匿名函数，该匿名函数每次调用时都会返回下一个数的平方
func squares() func() int {
	var x int
	fmt.Printf("origin: %p\n", &x) // 0xc000014128 --> 0xc000014138
	return func() int {
		fmt.Printf("%p\n", &x) // 0xc000014128 --> 0xc000014138
		// 所谓的：可以访问完整的词法环境，引用该函数的变量
		x++
		return x * x
	}
}
~~~

