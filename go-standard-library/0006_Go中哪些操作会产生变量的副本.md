今天我们重点说说 Go 中变量的**副本**！我们从 Go 语言中的**值方法**和**指针方法**引出“变量的副本”这个概念：

~~~go
func (ac AnimalCategory) String() string {
	return fmt.Sprintf("%s%s%s%s%s%s%s",
		ac.kingdom, ac.phylum, ac.class, ac.order,
		ac.family, ac.genus, ac.species)
}
~~~

有这样一段示例代码，显然：String() 的接收者是 `AnimalCategory` 类型。

方法的接收者类型必须是某个自定义的数据类型，不能是某个接口类型或者接口的指针类型。

* **值方法**的接收者类型：非指针的自定义数据类型；
* **指针方法**的接收者类型：某个基本类型的指针类型。

**（重点来了！）**值方法和指针方法的不同点在于：

1. **值方法**的接收者是该方法所属的那个类型变量的一个**副本**，在该方法内对该副本的修改一般不会体现在原值上，除非这个类型本身是某个引用类型的别名类型。**指针方法**的接收者是该方法所属的那个基本类型值的指针值的一个**副本**，在这样的方法上对该副本指向的值进行修改，一定会体现在原值上。
2. 一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合囊括前者的所有方法，即包括所有值方法和所有指针方法。严格来讲，我们在这样的基本类型的值上只能调用到它的值方法。但是，Go 语言会适时地为我们“自动转译”，使得我们在类型变量的值上也能调用到其类型的指针方法。特别说明的是：**这个自动转译，是 Go 语言的“语法糖”**。

经过上面的示例，我们得到了**第①种情况：变量在调用值方法和指针方法时，会产生一个副本**。

再来看下面的示例：

~~~go
package main

import "fmt"

type Pet interface {
	Name() string
}

type Dog struct {
	name string
}

func (dog Dog) Name() string {
	return ""
}

func (dog *Dog) SetName(name string) {
	dog.name = name
}

func main() {
	var pet Pet

	dog := Dog{name: "little pig"}
	pet = dog

	dog.SetName("monster")
	fmt.Println(dog, pet) // {monster} {little pig}
}
~~~

运行的结果显示：dog 变量的值的 name 字段发生了改动，而 pet 没有发生改动。

引发的疑问是：为什么 pet 变量的 name 字段没有发生改动？`pet = dog` 这个语句，本质上是一个**赋值语句**。

关于赋值的通用规则：如果我们使用了一个变量给另一个变量赋值，那么真正赋值给后者的，并不是前者持有的那个值，而是该值的一个**副本**。这个副本可以是**类型的值**，也可以是**类型的指针值**。`pet` 是接口变量，其动态值是 dog 的副本，其动态类型是 dog 变量的实际类型 Dog。

或者我们来看一个更加简化的变量赋值代码：

~~~go
func main() {
	dog1 := Dog{
		name: "little pig",
	}
	dog2 := dog1

	dog1.name = "monster"

	fmt.Println(dog2) // {little pig}
}
~~~

经过上面的示例，我们得到了**第②种情况：在将一个变量值赋值给另一个变量时，会产生一个副本**。

再来看下面的示例：

~~~go
func main() {
	dog1 := Dog{
		name: "little pig",
	}
	test(dog1)

	fmt.Println(dog1) // {little pig}
}

func test(dog Dog) {
	dog.name = "monster"
}
~~~

其实和第②种形式是类似的，不同之处在于，这种情况是在函数的调用过程发生了赋值，从而也产生了一个副本。这就是我们得到的**第 ③ 种情况：在函数调用过程中，为函数的参数赋值时会产生一个副本**。

因此，我总结了 3 种会出现变量副本的情况：

1. 变量在调用值方法和指针方法时，会产生一个副本；
2. 在将一个变量值赋值给另一个变量时，会产生一个副本；
3. 在函数调用过程中，为函数的参数赋值时会产生一个副本。

