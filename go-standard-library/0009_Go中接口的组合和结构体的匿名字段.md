本文解决 2 个知识点：

1. 接口的组合；
2. 结构体中嵌入字段（也可以被称为匿名字段）。

这两个知识点，一般使用在代码设计阶段，特别是对业务进行抽象、重构时。比如，将大的接口剥离成小接口，从而实现各个小接口的组合；同时，小接口也被称之为公共接口。

~~~go
// myDownloader 代表下载器的实现类型。
type myDownloader struct {
	// stub.ModuleInternal 代表组件基础实例。
	stub.ModuleInternal
	// httpClient 代表下载用的HTTP客户端。
	httpClient http.Client
}
~~~

从结构体字段声明来看，`stub.ModuleInternal` 是一个无名称的字段（该类型的定义和 `myDownloader` 类型定义在不同的 package 中），在 Go 中将这种情况称之为**嵌入字段**。不过很有意思的是，这个字段是一个**接口类型**：

~~~go
// ModuleInternal 代表组件的内部基础接口类型。
type ModuleInternal interface {
	// 接口类型嵌入了另外的接口类型
	module.Module
	// IncrCalledCount 会把调用计数增1。
	IncrCalledCount()
	// IncrAcceptedCount 会把接受计数增1。
	IncrAcceptedCount()
	// IncrCompletedCount 会把成功完成计数增1。
	IncrCompletedCount()
	// IncrHandlingNumber 会把实时处理数增1。
	IncrHandlingNumber()
	// DecrHandlingNumber 会把实时处理数减1。
	DecrHandlingNumber()
	// Clear 用于清空所有计数。
	Clear()
}
~~~

此外，更加特别的是，这个接口中又嵌入了另一个**接口** `module.Module`。同时也可以看出，`ModuleInternal` 和嵌入字段不在同一个包中：

~~~go
// Module 代表组件的基础接口类型。
// 该接口的实现类型必须是并发安全的！
type Module interface {
	// ID 用于获取当前组件的ID。
	ID() MID
	// Addr 用于获取当前组件的网络地址的字符串形式。
	Addr() string
	// Score 用于获取当前组件的评分。
	Score() uint64
	// 用于设置当前组件的评分。
	SetScore(score uint64)
	// ScoreCalculator 用于获取评分计算器。
	ScoreCalculator() CalculateScore
	// CallCount 用于获取当前组件被调用的计数。
	CalledCount() uint64
	// AcceptedCount 用于获取被当前组件接受的调用的计数。
	// 组件一般会由于超负荷或参数有误而拒绝调用。
	AcceptedCount() uint64
	// CompletedCount 用于获取当前组件已成功完成的调用的计数。
	CompletedCount() uint64
	// HandlingNumber 用于获取当前组件正在处理的调用的数量。
	HandlingNumber() uint64
	//Counts 用于一次性获取所有计数。
	Counts() Counts
	// Summary 用于获取组件摘要。
	Summary() SummaryStruct
}
~~~

从这个示例代码中，**抽象出 2 个知识点**：

* 接口类型之间的嵌入，或者可称之为**接口的组合**；

  接口组合，也就是上述例子中的：`ModuleInternal` 接口嵌入了 `module.Module` 接口。在使用时，只写接口类型名，无需写对应的字段名称。

  Go 语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。这是因为相比于包含很多方法的大接口而言，**小接口**可以更加专注地表达某一些能力或某一类特征，同时也**更容易被组合在一起**。

  对于上述示例：`ModuleInternal` 接口嵌入了 `module.Module` 接口，这样让 `ModuleInternal` 接口包含了 `module.Module` 接口的所有方法。

* **结构体中嵌入字段**（也可以被称为**匿名字段**），其中此处的字段可以是结构体类型，也可以是接口类型。Go 用这种方式，实现类型之间的组合。

  结构体组合，也就是上述例子中的：`myDownloader` 结构体定义中嵌入了接口类型的值 `stub.ModuleInternal`。在使用时，只写类型名，无需写对应的字段名称。

  对于嵌入字段的使用，有一个具有**重大意义的特征**：嵌入字段（`stub.ModuleInternal`）的方法集合会被无条件地合并进被嵌入类型（`myDownloader`）的方法集合中。也就是说，自然而然地被嵌入类型实现了嵌入字段所实现的接口。

  对于上述示例：`myDownloader` 在初始化时，会为 `stub.ModuleInternal` 字段赋值，且该值必定是实现了 `stub.ModuleInternal` 接口的所有方法。因此，对于 `myDownloader` 类型的变量，也就实现了 `stub.ModuleInternal` 接口的所有方法。

此处比较特别的是：**一般情况下，我们都是在结构体中嵌入另外一个结构体类型，而不会嵌入接口类型。此处，就是嵌入了一个接口类型**。

另外一个小知识点是：

~~~go
type Item map[string]interface{}

func TestItem(t *testing.T) {
	item := Item(map[string]interface{}{})
	if _, ok := interface{}(item).(Data); !ok {
		t.Fatalf("Item didn't implement Data!")
	}
	expectedValidity := true
	valid := item.Valid()
	if valid != expectedValidity {
		t.Fatalf("Inconsistent validity for item: expected: %v, actual: %v",
			expectedValidity, valid)
	}
	item = Item(nil)
	expectedValidity = false
	valid = item.Valid()
	if valid != expectedValidity {
		t.Fatalf("Inconsistent validity for item: expected: %v, actual: %v",
			expectedValidity, valid)
	}
}
~~~

特别是第 4 行代码：实际上是一个**类型转化的表达式** `Item(map[string]interface{}{})`，将表达式 `map[string]interface{}{}` 转化为 Item 类型。这种类型转化表达式的构成是：

~~~go
Conversion = Type "(" Expression [ "," ] ")" .
~~~

其中 Expression 是一个能够计算得到值的表达式，Type 则是一个类型。

因此，从 Go 语法角度来看，上述第 4 行代码是正确的。特别注意：`map[string]interface{}{}` 是一个 map 类型的值！